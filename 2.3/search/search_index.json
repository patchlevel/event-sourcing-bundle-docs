{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Event-Sourcing-Bundle A lightweight but also all-inclusive event sourcing bundle with a focus on developer experience and based on doctrine dbal. This bundle is a symfony integration for event-sourcing library. Features Everything is included in the package for event sourcing Based on doctrine dbal and their ecosystem Developer experience oriented and fully typed Snapshots system to quickly rebuild the aggregates Pipeline to build new projections or to migrate events Scheme management and doctrine migration support Dev tools such as a realtime event watcher Built in cli commands with symfony Installation composer require patchlevel/event-sourcing-bundle Warning If you don't use the symfony flex recipe for this bundle, you need to follow this installation documentation . Integration Psalm","title":"Introduction"},{"location":"#event-sourcing-bundle","text":"A lightweight but also all-inclusive event sourcing bundle with a focus on developer experience and based on doctrine dbal. This bundle is a symfony integration for event-sourcing library.","title":"Event-Sourcing-Bundle"},{"location":"#features","text":"Everything is included in the package for event sourcing Based on doctrine dbal and their ecosystem Developer experience oriented and fully typed Snapshots system to quickly rebuild the aggregates Pipeline to build new projections or to migrate events Scheme management and doctrine migration support Dev tools such as a realtime event watcher Built in cli commands with symfony","title":"Features"},{"location":"#installation","text":"composer require patchlevel/event-sourcing-bundle Warning If you don't use the symfony flex recipe for this bundle, you need to follow this installation documentation .","title":"Installation"},{"location":"#integration","text":"Psalm","title":"Integration"},{"location":"aggregate/","text":"Aggregate Info You can find out more about aggregates in the library documentation . This documentation is limited to bundle integration. Register aggregates A path must be specified for Event Sourcing to know where to look for your aggregates. patchlevel_event_sourcing : aggregates : '%kernel.project_dir%/src' Tip You can also define multiple paths by specifying an array. Define aggregates Next, you need to create a class to serve as an aggregate. In our example it is a hotel. This class must inherit from AggregateRoot and get the Aggregate attribute. namespace App\\Domain\\Hotel ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate(name: 'hotel')] final class Hotel extends AggregateRoot { // ... } Note You should read here how the aggregates then work internally.","title":"Aggregate"},{"location":"aggregate/#aggregate","text":"Info You can find out more about aggregates in the library documentation . This documentation is limited to bundle integration.","title":"Aggregate"},{"location":"aggregate/#register-aggregates","text":"A path must be specified for Event Sourcing to know where to look for your aggregates. patchlevel_event_sourcing : aggregates : '%kernel.project_dir%/src' Tip You can also define multiple paths by specifying an array.","title":"Register aggregates"},{"location":"aggregate/#define-aggregates","text":"Next, you need to create a class to serve as an aggregate. In our example it is a hotel. This class must inherit from AggregateRoot and get the Aggregate attribute. namespace App\\Domain\\Hotel ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate(name: 'hotel')] final class Hotel extends AggregateRoot { // ... } Note You should read here how the aggregates then work internally.","title":"Define aggregates"},{"location":"cli/","text":"CLI The bundle also offers cli commands to create or delete databases . It is also possible to manage the schema and projections . Database commands There are two commands for creating and deleting a database. event-sourcing:database:create event-sourcing:database:drop Schema commands The database schema can also be created, updated and dropped. event-sourcing:schema:create event-sourcing:schema:update event-sourcing:schema:drop Note You can also register doctrine migration commands, see the store documentation for this. Projection commands The creation, deletion and rebuilding of the projections is also possible via the cli. event-sourcing:projection:create event-sourcing:projection:drop event-sourcing:projection:rebuild Note The pipeline will be used to rebuild the projection.","title":"CLI"},{"location":"cli/#cli","text":"The bundle also offers cli commands to create or delete databases . It is also possible to manage the schema and projections .","title":"CLI"},{"location":"cli/#database-commands","text":"There are two commands for creating and deleting a database. event-sourcing:database:create event-sourcing:database:drop","title":"Database commands"},{"location":"cli/#schema-commands","text":"The database schema can also be created, updated and dropped. event-sourcing:schema:create event-sourcing:schema:update event-sourcing:schema:drop Note You can also register doctrine migration commands, see the store documentation for this.","title":"Schema commands"},{"location":"cli/#projection-commands","text":"The creation, deletion and rebuilding of the projections is also possible via the cli. event-sourcing:projection:create event-sourcing:projection:drop event-sourcing:projection:rebuild Note The pipeline will be used to rebuild the projection.","title":"Projection commands"},{"location":"clock/","text":"Clock The clock is used to return the current time as DateTimeImmutable. There is a system clock and a frozen clock for test purposes. Info You can find out more about clock in the library documentation . This documentation is limited to bundle integration. Testing You can freeze the clock for testing purposes: when@test : patchlevel_event_sourcing : clock : freeze : '2020-01-01 22:00:00' Note If freeze is not set, then the system clock is used. PSR-20 You can also use your own implementation of your choice. They only have to implement the interface of the psr-20 . You can then specify this service here: patchlevel_event_sourcing : clock : service : 'my_own_clock_service' Symfony Clock Since symfony 6.2 there is a clock implementation based on psr-20 that you can use. composer require symfony/clock patchlevel_event_sourcing : clock : service : 'clock'","title":"Time / Clock"},{"location":"clock/#clock","text":"The clock is used to return the current time as DateTimeImmutable. There is a system clock and a frozen clock for test purposes. Info You can find out more about clock in the library documentation . This documentation is limited to bundle integration.","title":"Clock"},{"location":"clock/#testing","text":"You can freeze the clock for testing purposes: when@test : patchlevel_event_sourcing : clock : freeze : '2020-01-01 22:00:00' Note If freeze is not set, then the system clock is used.","title":"Testing"},{"location":"clock/#psr-20","text":"You can also use your own implementation of your choice. They only have to implement the interface of the psr-20 . You can then specify this service here: patchlevel_event_sourcing : clock : service : 'my_own_clock_service'","title":"PSR-20"},{"location":"clock/#symfony-clock","text":"Since symfony 6.2 there is a clock implementation based on psr-20 that you can use. composer require symfony/clock patchlevel_event_sourcing : clock : service : 'clock'","title":"Symfony Clock"},{"location":"event_bus/","text":"Event Bus This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event will be dispatched to the event bus . All listeners are then called for each event. Info You can find out more about the event bus in the library documentation . This documentation is limited to bundle integration. Symfony Event Bus To use the Symfony Messager , you have to define it in messenger.yaml. It's best to call the bus \"event.bus\". An event bus can have 0 or n listener for an event. So \"allow_no_handlers\" has to be configured. framework : messenger : buses : event.bus : default_middleware : allow_no_handlers We can then use this message or event bus in event sourcing: patchlevel_event_sourcing : event_bus : service : event.bus Command Bus If you use a command bus or cqrs as a pattern, then you should define a new message bus. The whole thing can look like this: framework : messenger : default_bus : command.bus buses : command.bus : ~ event.bus : default_middleware : allow_no_handlers Warning You should deactivate the autoconfigure feature for the handlers, otherwise they will be registered in both handlers.","title":"Event Bus"},{"location":"event_bus/#event-bus","text":"This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event will be dispatched to the event bus . All listeners are then called for each event. Info You can find out more about the event bus in the library documentation . This documentation is limited to bundle integration.","title":"Event Bus"},{"location":"event_bus/#symfony-event-bus","text":"To use the Symfony Messager , you have to define it in messenger.yaml. It's best to call the bus \"event.bus\". An event bus can have 0 or n listener for an event. So \"allow_no_handlers\" has to be configured. framework : messenger : buses : event.bus : default_middleware : allow_no_handlers We can then use this message or event bus in event sourcing: patchlevel_event_sourcing : event_bus : service : event.bus","title":"Symfony Event Bus"},{"location":"event_bus/#command-bus","text":"If you use a command bus or cqrs as a pattern, then you should define a new message bus. The whole thing can look like this: framework : messenger : default_bus : command.bus buses : command.bus : ~ event.bus : default_middleware : allow_no_handlers Warning You should deactivate the autoconfigure feature for the handlers, otherwise they will be registered in both handlers.","title":"Command Bus"},{"location":"events/","text":"Events Events are used to describe things that happened in the application. Since the events already happened, they are also immutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions. Info You can find out more about events in the library documentation . This documentation is limited to bundle integration. Register events A path must be specified for Event Sourcing to know where to look for your evets. patchlevel_event_sourcing : events : '%kernel.project_dir%/src' Tip You can also define multiple paths by specifying an array. Define events Next, you need to create a class to serve as an event. This class must get the Event attribute with a unique event name. namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer ; use Symfony\\Component\\Uid\\Uuid ; #[Event('hotel.created')] final class HotelCreated { public function __construct ( #[UuidNormalizer] public readonly Uuid $id , public readonly string $hotelName ) { } } Note If you want to learn more about events, read the library documentation . Note You can read more about normalizer here .","title":"Events"},{"location":"events/#events","text":"Events are used to describe things that happened in the application. Since the events already happened, they are also immutable. In event sourcing, these are used to save and rebuild the current state. You can also listen on events to react and perform different actions. Info You can find out more about events in the library documentation . This documentation is limited to bundle integration.","title":"Events"},{"location":"events/#register-events","text":"A path must be specified for Event Sourcing to know where to look for your evets. patchlevel_event_sourcing : events : '%kernel.project_dir%/src' Tip You can also define multiple paths by specifying an array.","title":"Register events"},{"location":"events/#define-events","text":"Next, you need to create a class to serve as an event. This class must get the Event attribute with a unique event name. namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer ; use Symfony\\Component\\Uid\\Uuid ; #[Event('hotel.created')] final class HotelCreated { public function __construct ( #[UuidNormalizer] public readonly Uuid $id , public readonly string $hotelName ) { } } Note If you want to learn more about events, read the library documentation . Note You can read more about normalizer here .","title":"Define events"},{"location":"getting_started/","text":"Getting Started In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out. For this example we use following packages: symfony/uid symfony/mailer Installation First of all, the bundle has to be installed and configured. If you haven't already done so, see the installation introduction . Define some events First we define the events that happen in our system. A hotel can be created with a name : namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer ; use Symfony\\Component\\Uid\\Uuid ; #[Event('hotel.created')] final class HotelCreated { public function __construct ( #[UuidNormalizer] public readonly Uuid $id , public readonly string $hotelName ) { } } A guest can check in by name: namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('hotel.guest_is_checked_in')] final class GuestIsCheckedIn { public function __construct ( public readonly string $guestName ) { } } And also check out again: namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('hotel.guest_is_checked_out')] final class GuestIsCheckedOut { public function __construct ( public readonly string $guestName ) { } } Note You can find out more about events here . Define aggregates Next we need to define the aggregate. So the hotel and how the hotel should behave. We have also defined the create , checkIn and checkOut methods accordingly. These events are thrown here and the state of the hotel is also changed. namespace App\\Domain\\Hotel ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Symfony\\Component\\Uid\\Uuid ; #[Aggregate(name: 'hotel')] final class Hotel extends AggregateRoot { private Uuid $id ; private string $name ; /** * @var list<string> */ private array $guests ; public function name () : string { return $this -> name ; } public function guests () : int { return $this -> guests ; } public static function create ( Uuid $id , string $hotelName ) : self { $self = new self (); $self -> recordThat ( new HotelCreated ( $id , $hotelName )); return $self ; } public function checkIn ( string $guestName ) : void { if ( in_array ( $guestName , $this -> guests , true )) { throw new GuestHasAlreadyCheckedIn ( $guestName ); } $this -> recordThat ( new GuestIsCheckedIn ( guestName )); } public function checkOut ( string $guestName ) : void { if ( ! in_array ( $guestName , $this -> guests , true )) { throw new IsNotAGuest ( $guestName ); } $this -> recordThat ( new GuestIsCheckedOut ( $guestName )); } #[Apply] protected function applyHotelCreated ( HotelCreated $event ) : void { $this -> id = $event -> id ; $this -> name = $event -> hotelName ; $this -> guests = []; } #[Apply] protected function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> guests [] = $event -> guestName ; } #[Apply] protected function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> guests = array_values ( array_filter ( $this -> guests , fn ( $name ) => $name !== $event -> guestName ; ) ); } public function aggregateRootId () : string { return $this -> id -> toString (); } } Note You can find out more about aggregates here . Define projections So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. namespace App\\Projection ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projector\\Projector ; final class HotelProjection implements Projector { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } /** * @return list<array{id: string, name: string, guests: int}> */ public function getHotels () : array { return $this -> db -> fetchAllAssociative ( 'SELECT id, name, guests FROM hotel;' ) } #[Handle(HotelCreated::class)] public function handleHotelCreated ( Message $message ) : void { $this -> db -> insert ( 'hotel' , [ 'id' => $message -> aggregateId (), 'name' => $message -> event () -> hotelName (), 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } Warning autoconfigure need to be enabled, otherwise you need add the event_sourcing.projector tag. Note You can find out more about projections here . Processor In our example we also want to send an email to the head office as soon as a guest is checked in. namespace App\\Domain\\Hotel\\Listener ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Symfony\\Component\\Mailer\\MailerInterface ; use Symfony\\Component\\Mime\\Email ; final class SendCheckInEmailListener implements Listener { private MailerInterface $mailer ; private function __construct ( MailerInterface $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $email = ( new Email ()) -> from ( 'noreply@patchlevel.de' ) -> to ( 'hq@patchlevel.de' ) -> subject ( 'Guest is checked in' ) -> text ( sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ())); $this -> mailer -> send ( $email ); } } Warning autoconfigure need to be enabled, otherwise you need add the event_sourcing.processor tag. Note You can find out more about processor here . Database setup So that we can actually write the data to a database, we need the associated schema and databases. bin/console event-sourcing:database:create bin/console event-sourcing:schema:create bin/console event-sourcing:projection:create Usage We are now ready to use the Event Sourcing System. We can load, change and save aggregates. namespace App\\Controller ; use App\\Domain\\Hotel\\Hotel ; use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; use Symfony\\Component\\HttpFoundation\\JsonResponse ; use Symfony\\Component\\HttpFoundation\\Request ; use Symfony\\Component\\Routing\\Annotation\\Route ; use Symfony\\Component\\Uid\\Uuid ; final class HotelController { /** @var Repository<Hotel> */ private Repository $hotelRepository ; private HotelProjection $hotelProjection ; public function __construct ( RepositoryManager $repositoryManager , HotelProjection $hotelProjection ) { $this -> hotelRepository = $repositoryManager -> get ( Hotel :: class ); $this -> hotelProjection = $hotelProjection ; } #[Route(\"/\", methods:[\"GET\"])] public function listAction () : JsonResponse { return new JsonResponse ( $this -> hotelProjection -> getHotels () ); } #[Route(\"/create\", methods:[\"POST\"])] public function createAction ( Request $request ) : JsonResponse { $hotelName = $request -> request -> get ( 'name' ); // need validation! $id = Uuid :: v4 (); $hotel = Hotel :: create ( $id , $hotelName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse ([ 'id' => $id -> toString ()]); } #[Route(\"/:id/check-in\", methods:[\"POST\"])] public function checkInAction ( string $id , Request $request ) : JsonResponse { $id = Uuid :: fromString ( $id ); $guestName = $request -> request -> get ( 'name' ); // need validation! $hotel = $this -> hotelRepository -> load ( $id ); $hotel -> checkIn ( $guestName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse (); } #[Route(\"/:id/check-out\", methods:[\"POST\"])] public function checkOutAction ( string $id , Request $request ) : JsonResponse { $id = Uuid :: fromString ( $id ); $guestName = $request -> request -> get ( 'name' ); // need validation! $hotel = $this -> hotelRepository -> load ( $id ); $hotel -> checkOut ( $guestName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse (); } } Note You can also use a command bus .","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out. For this example we use following packages: symfony/uid symfony/mailer","title":"Getting Started"},{"location":"getting_started/#installation","text":"First of all, the bundle has to be installed and configured. If you haven't already done so, see the installation introduction .","title":"Installation"},{"location":"getting_started/#define-some-events","text":"First we define the events that happen in our system. A hotel can be created with a name : namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer ; use Symfony\\Component\\Uid\\Uuid ; #[Event('hotel.created')] final class HotelCreated { public function __construct ( #[UuidNormalizer] public readonly Uuid $id , public readonly string $hotelName ) { } } A guest can check in by name: namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('hotel.guest_is_checked_in')] final class GuestIsCheckedIn { public function __construct ( public readonly string $guestName ) { } } And also check out again: namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('hotel.guest_is_checked_out')] final class GuestIsCheckedOut { public function __construct ( public readonly string $guestName ) { } } Note You can find out more about events here .","title":"Define some events"},{"location":"getting_started/#define-aggregates","text":"Next we need to define the aggregate. So the hotel and how the hotel should behave. We have also defined the create , checkIn and checkOut methods accordingly. These events are thrown here and the state of the hotel is also changed. namespace App\\Domain\\Hotel ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Symfony\\Component\\Uid\\Uuid ; #[Aggregate(name: 'hotel')] final class Hotel extends AggregateRoot { private Uuid $id ; private string $name ; /** * @var list<string> */ private array $guests ; public function name () : string { return $this -> name ; } public function guests () : int { return $this -> guests ; } public static function create ( Uuid $id , string $hotelName ) : self { $self = new self (); $self -> recordThat ( new HotelCreated ( $id , $hotelName )); return $self ; } public function checkIn ( string $guestName ) : void { if ( in_array ( $guestName , $this -> guests , true )) { throw new GuestHasAlreadyCheckedIn ( $guestName ); } $this -> recordThat ( new GuestIsCheckedIn ( guestName )); } public function checkOut ( string $guestName ) : void { if ( ! in_array ( $guestName , $this -> guests , true )) { throw new IsNotAGuest ( $guestName ); } $this -> recordThat ( new GuestIsCheckedOut ( $guestName )); } #[Apply] protected function applyHotelCreated ( HotelCreated $event ) : void { $this -> id = $event -> id ; $this -> name = $event -> hotelName ; $this -> guests = []; } #[Apply] protected function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> guests [] = $event -> guestName ; } #[Apply] protected function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> guests = array_values ( array_filter ( $this -> guests , fn ( $name ) => $name !== $event -> guestName ; ) ); } public function aggregateRootId () : string { return $this -> id -> toString (); } } Note You can find out more about aggregates here .","title":"Define aggregates"},{"location":"getting_started/#define-projections","text":"So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. namespace App\\Projection ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projector\\Projector ; final class HotelProjection implements Projector { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } /** * @return list<array{id: string, name: string, guests: int}> */ public function getHotels () : array { return $this -> db -> fetchAllAssociative ( 'SELECT id, name, guests FROM hotel;' ) } #[Handle(HotelCreated::class)] public function handleHotelCreated ( Message $message ) : void { $this -> db -> insert ( 'hotel' , [ 'id' => $message -> aggregateId (), 'name' => $message -> event () -> hotelName (), 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } Warning autoconfigure need to be enabled, otherwise you need add the event_sourcing.projector tag. Note You can find out more about projections here .","title":"Define projections"},{"location":"getting_started/#processor","text":"In our example we also want to send an email to the head office as soon as a guest is checked in. namespace App\\Domain\\Hotel\\Listener ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Symfony\\Component\\Mailer\\MailerInterface ; use Symfony\\Component\\Mime\\Email ; final class SendCheckInEmailListener implements Listener { private MailerInterface $mailer ; private function __construct ( MailerInterface $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $email = ( new Email ()) -> from ( 'noreply@patchlevel.de' ) -> to ( 'hq@patchlevel.de' ) -> subject ( 'Guest is checked in' ) -> text ( sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ())); $this -> mailer -> send ( $email ); } } Warning autoconfigure need to be enabled, otherwise you need add the event_sourcing.processor tag. Note You can find out more about processor here .","title":"Processor"},{"location":"getting_started/#database-setup","text":"So that we can actually write the data to a database, we need the associated schema and databases. bin/console event-sourcing:database:create bin/console event-sourcing:schema:create bin/console event-sourcing:projection:create","title":"Database setup"},{"location":"getting_started/#usage","text":"We are now ready to use the Event Sourcing System. We can load, change and save aggregates. namespace App\\Controller ; use App\\Domain\\Hotel\\Hotel ; use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; use Symfony\\Component\\HttpFoundation\\JsonResponse ; use Symfony\\Component\\HttpFoundation\\Request ; use Symfony\\Component\\Routing\\Annotation\\Route ; use Symfony\\Component\\Uid\\Uuid ; final class HotelController { /** @var Repository<Hotel> */ private Repository $hotelRepository ; private HotelProjection $hotelProjection ; public function __construct ( RepositoryManager $repositoryManager , HotelProjection $hotelProjection ) { $this -> hotelRepository = $repositoryManager -> get ( Hotel :: class ); $this -> hotelProjection = $hotelProjection ; } #[Route(\"/\", methods:[\"GET\"])] public function listAction () : JsonResponse { return new JsonResponse ( $this -> hotelProjection -> getHotels () ); } #[Route(\"/create\", methods:[\"POST\"])] public function createAction ( Request $request ) : JsonResponse { $hotelName = $request -> request -> get ( 'name' ); // need validation! $id = Uuid :: v4 (); $hotel = Hotel :: create ( $id , $hotelName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse ([ 'id' => $id -> toString ()]); } #[Route(\"/:id/check-in\", methods:[\"POST\"])] public function checkInAction ( string $id , Request $request ) : JsonResponse { $id = Uuid :: fromString ( $id ); $guestName = $request -> request -> get ( 'name' ); // need validation! $hotel = $this -> hotelRepository -> load ( $id ); $hotel -> checkIn ( $guestName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse (); } #[Route(\"/:id/check-out\", methods:[\"POST\"])] public function checkOutAction ( string $id , Request $request ) : JsonResponse { $id = Uuid :: fromString ( $id ); $guestName = $request -> request -> get ( 'name' ); // need validation! $hotel = $this -> hotelRepository -> load ( $id ); $hotel -> checkOut ( $guestName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse (); } } Note You can also use a command bus .","title":"Usage"},{"location":"installation/","text":"Installation If you are not using a symfony flex or the recipes for it, then you have to carry out a few installation steps by hand. Require package The first thing to do is to install packet if it has not already been done. composer require patchlevel/event-sourcing-bundle Note how to install composer Enable bundle Then we have to activate the bundle in the config/bundles.php : return [ Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle :: class => [ 'all' => true ], ]; If you don't have config/bundles.php then you need to add the bundle in the kernel: class AppKernel extends Kernel { public function registerBundles () { $bundles = [ new Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle (), ]; } } Configuration file Now you have to add a minimal configuration file here config/packages/patchlevel_event_sourcing.yaml . patchlevel_event_sourcing : aggregates : '%kernel.project_dir%/src' events : '%kernel.project_dir%/src' connection : url : '%env(EVENTSTORE_URL)%' Dotenv Finally we have to fill the ENV variable with a connection url. EVENTSTORE_URL=mysql://user:secret@localhost/app Note You can find out more about what a connection url looks like here . Now you can go back to getting started .","title":"Installation"},{"location":"installation/#installation","text":"If you are not using a symfony flex or the recipes for it, then you have to carry out a few installation steps by hand.","title":"Installation"},{"location":"installation/#require-package","text":"The first thing to do is to install packet if it has not already been done. composer require patchlevel/event-sourcing-bundle Note how to install composer","title":"Require package"},{"location":"installation/#enable-bundle","text":"Then we have to activate the bundle in the config/bundles.php : return [ Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle :: class => [ 'all' => true ], ]; If you don't have config/bundles.php then you need to add the bundle in the kernel: class AppKernel extends Kernel { public function registerBundles () { $bundles = [ new Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle (), ]; } }","title":"Enable bundle"},{"location":"installation/#configuration-file","text":"Now you have to add a minimal configuration file here config/packages/patchlevel_event_sourcing.yaml . patchlevel_event_sourcing : aggregates : '%kernel.project_dir%/src' events : '%kernel.project_dir%/src' connection : url : '%env(EVENTSTORE_URL)%'","title":"Configuration file"},{"location":"installation/#dotenv","text":"Finally we have to fill the ENV variable with a connection url. EVENTSTORE_URL=mysql://user:secret@localhost/app Note You can find out more about what a connection url looks like here . Now you can go back to getting started .","title":"Dotenv"},{"location":"message_decorator/","text":"Message Decorator There are usecases where you want to add some extra context to your events like metadata which is not directly relevant for your domain. With MessageDecorator we are providing a solution to add this metadata to your events. The metadata will also be persisted in the database and can be retrieved later on. Info You can find out more about message decorator in the library documentation . This documentation is limited to bundle integration. Usage We want to add the header information which user was logged in when this event was generated. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface ; final class LoggedUserDecorator implements MessageDecorator { public function __construct ( private readonly TokenStorageInterface $tokenStorage ) {} public function __invoke ( Message $message ) : Message { $token = $this -> tokenStorage -> getToken (); if ( ! $token ) { return ; } return $message -> withCustomHeader ( 'user' , $token -> getUserIdentifier ()); } } If you have the symfony default service setting with autowire and autoconfigure enabled, the message decorator is automatically recognized and registered at the MessageDecorator interface. Otherwise you have to define the message decorator in the symfony service file: services : App\\Message\\Decorator\\LoggedUserDecorator : tags : - event_sourcing.message_decorator","title":"Message Decorator"},{"location":"message_decorator/#message-decorator","text":"There are usecases where you want to add some extra context to your events like metadata which is not directly relevant for your domain. With MessageDecorator we are providing a solution to add this metadata to your events. The metadata will also be persisted in the database and can be retrieved later on. Info You can find out more about message decorator in the library documentation . This documentation is limited to bundle integration.","title":"Message Decorator"},{"location":"message_decorator/#usage","text":"We want to add the header information which user was logged in when this event was generated. use Patchlevel\\EventSourcing\\EventBus\\Message ; use Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface ; final class LoggedUserDecorator implements MessageDecorator { public function __construct ( private readonly TokenStorageInterface $tokenStorage ) {} public function __invoke ( Message $message ) : Message { $token = $this -> tokenStorage -> getToken (); if ( ! $token ) { return ; } return $message -> withCustomHeader ( 'user' , $token -> getUserIdentifier ()); } } If you have the symfony default service setting with autowire and autoconfigure enabled, the message decorator is automatically recognized and registered at the MessageDecorator interface. Otherwise you have to define the message decorator in the symfony service file: services : App\\Message\\Decorator\\LoggedUserDecorator : tags : - event_sourcing.message_decorator","title":"Usage"},{"location":"migration/","text":"Migration You can use doctrine migration, which is known from doctrine orm, to create your schema and keep it in sync. Info You can find out more about migration in the library documentation . This documentation is limited to bundle integration. Installation In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations Migration commands After the migration lib has been installed, the migration commands are automatically configured: ExecuteCommand: event-sourcing:migrations:execute GenerateCommand: event-sourcing:migrations:generate LatestCommand: event-sourcing:migrations:latest ListCommand: event-sourcing:migrations:list MigrateCommand: event-sourcing:migrations:migrate DiffCommand: event-sourcing:migrations:diff StatusCommand: event-sourcing:migrations:status VersionCommand: event-sourcing:migrations:version Configure You can also configure the migration integration. Here is an example with the default values: patchlevel_event_sourcing : migration : namespace : 'EventSourcingMigrations' path : '%kernel.project_dir%/migrations'","title":"Schema Migration"},{"location":"migration/#migration","text":"You can use doctrine migration, which is known from doctrine orm, to create your schema and keep it in sync. Info You can find out more about migration in the library documentation . This documentation is limited to bundle integration.","title":"Migration"},{"location":"migration/#installation","text":"In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations","title":"Installation"},{"location":"migration/#migration-commands","text":"After the migration lib has been installed, the migration commands are automatically configured: ExecuteCommand: event-sourcing:migrations:execute GenerateCommand: event-sourcing:migrations:generate LatestCommand: event-sourcing:migrations:latest ListCommand: event-sourcing:migrations:list MigrateCommand: event-sourcing:migrations:migrate DiffCommand: event-sourcing:migrations:diff StatusCommand: event-sourcing:migrations:status VersionCommand: event-sourcing:migrations:version","title":"Migration commands"},{"location":"migration/#configure","text":"You can also configure the migration integration. Here is an example with the default values: patchlevel_event_sourcing : migration : namespace : 'EventSourcingMigrations' path : '%kernel.project_dir%/migrations'","title":"Configure"},{"location":"normalizer/","text":"Normalizer Sometimes you also want to add more complex data in events as payload or in aggregates for the snapshots. For example DateTime, enums or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. Info You can find out more about normalizer in the library documentation . This documentation is limited to bundle integration. Built-in Normalizer This bundle adds more Symfony specific normalizers in addition to the existing built-in normalizers. Note You can find the other build-in normalizers here Uuid With the Uuid Normalizer, as the name suggests, you can convert Symfony Uuid objects to a string and back again. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer ; use Symfony\\Component\\Uid\\Uuid ; final class DTO { #[UuidNormalizer] public Uuid $id ; }","title":"Normalizer"},{"location":"normalizer/#normalizer","text":"Sometimes you also want to add more complex data in events as payload or in aggregates for the snapshots. For example DateTime, enums or value objects. You can do that too. However, you must define a normalizer for this so that the library knows how to write this data to the database and load it again. Info You can find out more about normalizer in the library documentation . This documentation is limited to bundle integration.","title":"Normalizer"},{"location":"normalizer/#built-in-normalizer","text":"This bundle adds more Symfony specific normalizers in addition to the existing built-in normalizers. Note You can find the other build-in normalizers here","title":"Built-in Normalizer"},{"location":"normalizer/#uuid","text":"With the Uuid Normalizer, as the name suggests, you can convert Symfony Uuid objects to a string and back again. use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer ; use Symfony\\Component\\Uid\\Uuid ; final class DTO { #[UuidNormalizer] public Uuid $id ; }","title":"Uuid"},{"location":"pipeline/","text":"Pipeline A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. Info You can find out more about pipeline in the library documentation . This documentation is limited to bundle integration. Example In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : namespace App\\Command ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; use Patchlevel\\EventSourcing\\Serializer\\Serializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; use Patchlevel\\EventSourcing\\Store\\Store ; use Symfony\\Component\\Console\\Command\\Command ; use Symfony\\Component\\Console\\Input\\InputInterface ; use Symfony\\Component\\Console\\Output\\OutputInterface ; use Symfony\\Component\\Console\\Style\\SymfonyStyle ; class CreateUserCommand extends Command { protected static $defaultName = 'app:event-sourcing:migrate-db-v2' ; private Store $oldStore ; private Connection $newConnection ; private Serializer $serializer ; private AggregateRootRegistry $aggregateRegistry ; public function __construct ( Store $oldStore , Connection $newConnection , Serializer $serializer , AggregateRootRegistry $aggregateRegistry ) { $this -> oldStore = $oldStore ; $this -> newConnection = $newConnection ; $this -> serializer = $serializer ; $this -> aggregateRegistry = $aggregateRegistry ; parent :: __construct (); } protected function configure () : void { } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $console = new SymfonyStyle ( $input , $output ); $newStore = new MultiTableStore ( $this -> newConnection , $this -> serializer , $this -> aggregateRegistry ); $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return NewVisited :: raise ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); $console -> progressStart ( $pipeline -> count ()); $pipeline -> run ( static function () use ( $console ) : void { $console -> progressAdvance (); }); $console -> progressFinish (); $console -> success ( 'finish' ); return Command :: SUCCESS ; } } The whole thing just has to be plugged together. services : App\\Command\\CreateUserCommand : arguments : newConnection : '@doctrine.dbal.new_connection' Note If you have the doctrine bundle for the dbal connections, then you can autowire it.","title":"Pipeline"},{"location":"pipeline/#pipeline","text":"A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. Info You can find out more about pipeline in the library documentation . This documentation is limited to bundle integration.","title":"Pipeline"},{"location":"pipeline/#example","text":"In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : namespace App\\Command ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; use Patchlevel\\EventSourcing\\Serializer\\Serializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; use Patchlevel\\EventSourcing\\Store\\Store ; use Symfony\\Component\\Console\\Command\\Command ; use Symfony\\Component\\Console\\Input\\InputInterface ; use Symfony\\Component\\Console\\Output\\OutputInterface ; use Symfony\\Component\\Console\\Style\\SymfonyStyle ; class CreateUserCommand extends Command { protected static $defaultName = 'app:event-sourcing:migrate-db-v2' ; private Store $oldStore ; private Connection $newConnection ; private Serializer $serializer ; private AggregateRootRegistry $aggregateRegistry ; public function __construct ( Store $oldStore , Connection $newConnection , Serializer $serializer , AggregateRootRegistry $aggregateRegistry ) { $this -> oldStore = $oldStore ; $this -> newConnection = $newConnection ; $this -> serializer = $serializer ; $this -> aggregateRegistry = $aggregateRegistry ; parent :: __construct (); } protected function configure () : void { } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $console = new SymfonyStyle ( $input , $output ); $newStore = new MultiTableStore ( $this -> newConnection , $this -> serializer , $this -> aggregateRegistry ); $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return NewVisited :: raise ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); $console -> progressStart ( $pipeline -> count ()); $pipeline -> run ( static function () use ( $console ) : void { $console -> progressAdvance (); }); $console -> progressFinish (); $console -> success ( 'finish' ); return Command :: SUCCESS ; } } The whole thing just has to be plugged together. services : App\\Command\\CreateUserCommand : arguments : newConnection : '@doctrine.dbal.new_connection' Note If you have the doctrine bundle for the dbal connections, then you can autowire it.","title":"Example"},{"location":"processor/","text":"Processor The processor is a kind of event bus listener that can execute actions on certain events. Info You can find out more about processor in the library documentation . This documentation is limited to bundle integration. Usage A process can be for example used to send an email when a guest is checked in: namespace App\\Domain\\Hotel\\Listener ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Symfony\\Component\\Mailer\\MailerInterface ; use Symfony\\Component\\Mime\\Email ; final class SendCheckInEmailListener implements Listener { private MailerInterface $mailer ; private function __construct ( MailerInterface $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $email = ( new Email ()) -> from ( 'noreply@patchlevel.de' ) -> to ( 'hq@patchlevel.de' ) -> subject ( 'Guest is checked in' ) -> text ( sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ())); $this -> mailer -> send ( $email ); } } If you have the symfony default service setting with autowire and autoconfiger enabled, the processor is automatically recognized and registered at the Listener interface. Otherwise you have to define the processor in the symfony service file: services : App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener : tags : - event_sourcing.processor Priority You can also determine the priority in which the processors are executed. The higher the priority, the earlier the processor is executed. You have to add the tag manually and specify the priority. services : App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener : autoconfigure : false tags : - name : event_sourcing.processor priority : 16 Warning You have to deactivate the autoconfigure for this service, otherwise the service will be added twice. Note The projection listener has a priority of -32 , to do things after the projection, you have to be lower.","title":"Processor"},{"location":"processor/#processor","text":"The processor is a kind of event bus listener that can execute actions on certain events. Info You can find out more about processor in the library documentation . This documentation is limited to bundle integration.","title":"Processor"},{"location":"processor/#usage","text":"A process can be for example used to send an email when a guest is checked in: namespace App\\Domain\\Hotel\\Listener ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Symfony\\Component\\Mailer\\MailerInterface ; use Symfony\\Component\\Mime\\Email ; final class SendCheckInEmailListener implements Listener { private MailerInterface $mailer ; private function __construct ( MailerInterface $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $email = ( new Email ()) -> from ( 'noreply@patchlevel.de' ) -> to ( 'hq@patchlevel.de' ) -> subject ( 'Guest is checked in' ) -> text ( sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ())); $this -> mailer -> send ( $email ); } } If you have the symfony default service setting with autowire and autoconfiger enabled, the processor is automatically recognized and registered at the Listener interface. Otherwise you have to define the processor in the symfony service file: services : App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener : tags : - event_sourcing.processor","title":"Usage"},{"location":"processor/#priority","text":"You can also determine the priority in which the processors are executed. The higher the priority, the earlier the processor is executed. You have to add the tag manually and specify the priority. services : App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener : autoconfigure : false tags : - name : event_sourcing.processor priority : 16 Warning You have to deactivate the autoconfigure for this service, otherwise the service will be added twice. Note The projection listener has a priority of -32 , to do things after the projection, you have to be lower.","title":"Priority"},{"location":"projection/","text":"Projection With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch. Info You can find out more about projection in the library documentation . This documentation is limited to bundle integration. Define Projection In this example we are simply mapping hotel statistics: namespace App\\Projection ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projector\\Projector ; final class HotelProjection implements Projector { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } /** * @return list<array{id: string, name: string, guests: int}> */ public function getHotels () : array { return $this -> db -> fetchAllAssociative ( 'SELECT id, name, guests FROM hotel;' ) } #[Handle(HotelCreated::class)] public function handleHotelCreated ( Message $message ) : void { $event = $message -> event (); $this -> db -> insert ( 'hotel' , [ 'id' => $event -> aggregateId (), 'name' => $event -> hotelName (), 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $event = $message -> event (); $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $event -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $event = $message -> event (); $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $event -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } If you have the symfony default service setting with autowire and autoconfigure enabled, the projection is automatically recognized and registered at the Projector interface. Otherwise you have to define the projection in the symfony service file: services : App\\Projection\\HotelProjection : tags : - event_sourcing.projector Projection commands The bundle also provides a few commands to create, delete or rebuild projections: bin/console event-sourcing:projection:create bin/console event-sourcing:projection:drop bin/console event-sourcing:projection:rebuild","title":"Projection"},{"location":"projection/#projection","text":"With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch. Info You can find out more about projection in the library documentation . This documentation is limited to bundle integration.","title":"Projection"},{"location":"projection/#define-projection","text":"In this example we are simply mapping hotel statistics: namespace App\\Projection ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projector\\Projector ; final class HotelProjection implements Projector { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } /** * @return list<array{id: string, name: string, guests: int}> */ public function getHotels () : array { return $this -> db -> fetchAllAssociative ( 'SELECT id, name, guests FROM hotel;' ) } #[Handle(HotelCreated::class)] public function handleHotelCreated ( Message $message ) : void { $event = $message -> event (); $this -> db -> insert ( 'hotel' , [ 'id' => $event -> aggregateId (), 'name' => $event -> hotelName (), 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $event = $message -> event (); $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $event -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $event = $message -> event (); $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $event -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } If you have the symfony default service setting with autowire and autoconfigure enabled, the projection is automatically recognized and registered at the Projector interface. Otherwise you have to define the projection in the symfony service file: services : App\\Projection\\HotelProjection : tags : - event_sourcing.projector","title":"Define Projection"},{"location":"projection/#projection-commands","text":"The bundle also provides a few commands to create, delete or rebuild projections: bin/console event-sourcing:projection:create bin/console event-sourcing:projection:drop bin/console event-sourcing:projection:rebuild","title":"Projection commands"},{"location":"repository/","text":"Repository A repository takes care of storing and loading the aggregates . The design pattern of the same name is also used. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate. Info You can find out more about repository in the library documentation . This documentation is limited to bundle integration. Use repositories You can access the specific repositories using the RepositoryManager . use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; final class HotelController { public function doStuffAction ( RepositoryManager $repositoryManager ) : Response { $hotelRepository = $repositoryManager -> get ( Hotel :: class ); $hotel = $hotelRepository -> load ( '1' ); $hotel -> doStuff (); $hotelRepository -> save ( $hotel ); // ... } } Custom Repositories In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security. use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; class HotelRepository { /** @var Repository<Hotel> */ private Repository $repository ; public function __construct ( RepositoryManager $repositoryManager ) { $this -> repository = $repositoryManager -> get ( Hotel :: class ); } public function load ( HotelId $id ) : Hotel { return $this -> repository -> load ( $id -> toString ()); } public function save ( Hotel $hotel ) : void { return $this -> repository -> save ( $hotel ); } public function has ( HotelId $id ) : bool { return $this -> repository -> has ( $id -> toString ()); } }","title":"Repository"},{"location":"repository/#repository","text":"A repository takes care of storing and loading the aggregates . The design pattern of the same name is also used. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate. Info You can find out more about repository in the library documentation . This documentation is limited to bundle integration.","title":"Repository"},{"location":"repository/#use-repositories","text":"You can access the specific repositories using the RepositoryManager . use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; final class HotelController { public function doStuffAction ( RepositoryManager $repositoryManager ) : Response { $hotelRepository = $repositoryManager -> get ( Hotel :: class ); $hotel = $hotelRepository -> load ( '1' ); $hotel -> doStuff (); $hotelRepository -> save ( $hotel ); // ... } }","title":"Use repositories"},{"location":"repository/#custom-repositories","text":"In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security. use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; class HotelRepository { /** @var Repository<Hotel> */ private Repository $repository ; public function __construct ( RepositoryManager $repositoryManager ) { $this -> repository = $repositoryManager -> get ( Hotel :: class ); } public function load ( HotelId $id ) : Hotel { return $this -> repository -> load ( $id -> toString ()); } public function save ( Hotel $hotel ) : void { return $this -> repository -> save ( $hotel ); } public function has ( HotelId $id ) : bool { return $this -> repository -> has ( $id -> toString ()); } }","title":"Custom Repositories"},{"location":"snapshots/","text":"Snapshots Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all. Info You can find out more about snapshots in the library documentation . This documentation is limited to bundle integration. Using Symfony Cache You can use symfony cache to define the target of the snapshot store. framework : cache : default_redis_provider : 'redis://localhost' pools : event_sourcing.cache : adapter : cache.adapter.redis After this, you need define the snapshot store. Symfony cache implement the psr6 interface, so we need choose this type and enter the id from the cache service. patchlevel_event_sourcing : snapshot_stores : default : service : event_sourcing.cache Finally, you have to tell the aggregate that it should use this snapshot store. namespace App\\Domain\\Profile ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'profile')] #[Snapshot('default')] final class Profile extends AggregateRoot { // ... } Book You can find out more about the attributes here . Batch So that not every write process also writes to the cache at the same time, you can also say from how many events should be written to the snapshot store first. This minimizes the write operations to the cache, which improves performance. namespace App\\Domain\\Profile ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'profile')] #[Snapshot('default', batch: 1000)] final class Profile extends AggregateRoot { // ... }","title":"Snapshots"},{"location":"snapshots/#snapshots","text":"Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all. Info You can find out more about snapshots in the library documentation . This documentation is limited to bundle integration.","title":"Snapshots"},{"location":"snapshots/#using-symfony-cache","text":"You can use symfony cache to define the target of the snapshot store. framework : cache : default_redis_provider : 'redis://localhost' pools : event_sourcing.cache : adapter : cache.adapter.redis After this, you need define the snapshot store. Symfony cache implement the psr6 interface, so we need choose this type and enter the id from the cache service. patchlevel_event_sourcing : snapshot_stores : default : service : event_sourcing.cache Finally, you have to tell the aggregate that it should use this snapshot store. namespace App\\Domain\\Profile ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'profile')] #[Snapshot('default')] final class Profile extends AggregateRoot { // ... } Book You can find out more about the attributes here .","title":"Using Symfony Cache"},{"location":"snapshots/#batch","text":"So that not every write process also writes to the cache at the same time, you can also say from how many events should be written to the snapshot store first. This minimizes the write operations to the cache, which improves performance. namespace App\\Domain\\Profile ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'profile')] #[Snapshot('default', batch: 1000)] final class Profile extends AggregateRoot { // ... }","title":"Batch"},{"location":"store/","text":"Store In the end, the events have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. Info You can find out more about stores in the library documentation . This documentation is limited to bundle integration. Store types We offer two store strategies that you can choose as you like. Single Table Store With the single_table everything is saved in one table. patchlevel_event_sourcing : store : type : single_table Note You can switch between strategies using the pipeline . Multi Table Store With the multi_table a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. patchlevel_event_sourcing : store : type : multi_table Note You can switch between strategies using the pipeline . Manage database and schema The bundle provides you with a few commands with which you can create and delete the database . You can also use it to create, edit and delete the schema . Create and drop database bin/console event-sourcing:database:create bin/console event-sourcing:database:drop Create, update and drop schema bin/console event-sourcing:schema:create bin/console event-sourcing:schema:udapte bin/console event-sourcing:schema:drop Use doctrine connection If you have installed the doctrine bundle , you can also define the connection via doctrine and then use it in the store. doctrine : dbal : connections : eventstore : url : '%env(EVENTSTORE_URL)%' patchlevel_event_sourcing : connection : service : doctrine.dbal.eventstore_connection Warning If you want to use the same connection as doctrine orm, then you have to set the flag merge_orm_schema . Otherwise you should avoid using the same connection as other tools. Note You can find out more about the dbal configuration here . Migration You can also manage your schema with doctrine migrations. In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations With this package, further commands are available such as. for creating and executing migrations. bin/console event-sourcing:migration:diff bin/console event-sourcing:migration:migrate You can also change the namespace and the folder in the configuration. patchlevel_event_sourcing : migration : namespace : EventSourcingMigrations path : \"%kernel.project_dir%/migrations\" Merge ORM Schema You can also merge the schema with doctrine orm. You have to set the following flag for this: patchlevel_event_sourcing : store : merge_orm_schema : true Note All schema relevant commands are removed if you activate this option. You should use the doctrine commands then. Warning If you want to merge the schema, then the same doctrine connection must be used as with the doctrine orm. Otherwise errors may occur!","title":"Store"},{"location":"store/#store","text":"In the end, the events have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. Info You can find out more about stores in the library documentation . This documentation is limited to bundle integration.","title":"Store"},{"location":"store/#store-types","text":"We offer two store strategies that you can choose as you like.","title":"Store types"},{"location":"store/#single-table-store","text":"With the single_table everything is saved in one table. patchlevel_event_sourcing : store : type : single_table Note You can switch between strategies using the pipeline .","title":"Single Table Store"},{"location":"store/#multi-table-store","text":"With the multi_table a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. patchlevel_event_sourcing : store : type : multi_table Note You can switch between strategies using the pipeline .","title":"Multi Table Store"},{"location":"store/#manage-database-and-schema","text":"The bundle provides you with a few commands with which you can create and delete the database . You can also use it to create, edit and delete the schema .","title":"Manage database and schema"},{"location":"store/#create-and-drop-database","text":"bin/console event-sourcing:database:create bin/console event-sourcing:database:drop","title":"Create and drop database"},{"location":"store/#create-update-and-drop-schema","text":"bin/console event-sourcing:schema:create bin/console event-sourcing:schema:udapte bin/console event-sourcing:schema:drop","title":"Create, update and drop schema"},{"location":"store/#use-doctrine-connection","text":"If you have installed the doctrine bundle , you can also define the connection via doctrine and then use it in the store. doctrine : dbal : connections : eventstore : url : '%env(EVENTSTORE_URL)%' patchlevel_event_sourcing : connection : service : doctrine.dbal.eventstore_connection Warning If you want to use the same connection as doctrine orm, then you have to set the flag merge_orm_schema . Otherwise you should avoid using the same connection as other tools. Note You can find out more about the dbal configuration here .","title":"Use doctrine connection"},{"location":"store/#migration","text":"You can also manage your schema with doctrine migrations. In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations With this package, further commands are available such as. for creating and executing migrations. bin/console event-sourcing:migration:diff bin/console event-sourcing:migration:migrate You can also change the namespace and the folder in the configuration. patchlevel_event_sourcing : migration : namespace : EventSourcingMigrations path : \"%kernel.project_dir%/migrations\"","title":"Migration"},{"location":"store/#merge-orm-schema","text":"You can also merge the schema with doctrine orm. You have to set the following flag for this: patchlevel_event_sourcing : store : merge_orm_schema : true Note All schema relevant commands are removed if you activate this option. You should use the doctrine commands then. Warning If you want to merge the schema, then the same doctrine connection must be used as with the doctrine orm. Otherwise errors may occur!","title":"Merge ORM Schema"},{"location":"upcasting/","text":"Upcasting There are cases where the already have events in our stream but there is data missing or not in the right format for our new usecase. Normally you would need to create versioned events for this. This can lead to many versions of the same event which could lead to some chaos. To prevent this we offer Upcaster , which can operate on the payload before denormalizing to an event object. There you can change the event name and adjust the payload of the event. Info You can find out more about upcasting in the library documentation . This documentation is limited to bundle integration. Usage use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; final class ProfileCreatedEmailLowerCastUpcaster implements Upcaster { public function __invoke ( Upcast $upcast ) : Upcast { // ignore if other event is processed if ( $upcast -> eventName !== 'profile_created' ) { return $upcast ; } $payload = $upcast -> payload ; $payload [ 'email' ] = strtolower ( $payload [ 'email' ]); return new Upcast ( $upcast -> eventName , $payload ) } } If you have the symfony default service setting with autowire and autoconfigure enabled, the upcaster is automatically recognized and registered at the Upcaster interface. Otherwise you have to define the upcaster in the symfony service file: services : App\\Upcaster\\ProfileCreatedEmailLowerCastUpcaster : tags : - event_sourcing.upcaster","title":"Upcasting"},{"location":"upcasting/#upcasting","text":"There are cases where the already have events in our stream but there is data missing or not in the right format for our new usecase. Normally you would need to create versioned events for this. This can lead to many versions of the same event which could lead to some chaos. To prevent this we offer Upcaster , which can operate on the payload before denormalizing to an event object. There you can change the event name and adjust the payload of the event. Info You can find out more about upcasting in the library documentation . This documentation is limited to bundle integration.","title":"Upcasting"},{"location":"upcasting/#usage","text":"use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast ; use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster ; final class ProfileCreatedEmailLowerCastUpcaster implements Upcaster { public function __invoke ( Upcast $upcast ) : Upcast { // ignore if other event is processed if ( $upcast -> eventName !== 'profile_created' ) { return $upcast ; } $payload = $upcast -> payload ; $payload [ 'email' ] = strtolower ( $payload [ 'email' ]); return new Upcast ( $upcast -> eventName , $payload ) } } If you have the symfony default service setting with autowire and autoconfigure enabled, the upcaster is automatically recognized and registered at the Upcaster interface. Otherwise you have to define the upcaster in the symfony service file: services : App\\Upcaster\\ProfileCreatedEmailLowerCastUpcaster : tags : - event_sourcing.upcaster","title":"Usage"},{"location":"watch_server/","text":"Watch Server There is also a watch server, because you can start to see all events in real time. Info You can find out more about the watch server in the library documentation . This documentation is limited to bundle integration. Configuration To do this, you have to add the following configuration for the dev environment: patchlevel_event_sourcing : watch_server : enabled : true Warning Use this configuration for dev purposes only! Watch There is then a new command to start the watch server: bin/console event-sourcing:watch Note The command can be terminated with ctrl+c or control+c .","title":"Watch Server"},{"location":"watch_server/#watch-server","text":"There is also a watch server, because you can start to see all events in real time. Info You can find out more about the watch server in the library documentation . This documentation is limited to bundle integration.","title":"Watch Server"},{"location":"watch_server/#configuration","text":"To do this, you have to add the following configuration for the dev environment: patchlevel_event_sourcing : watch_server : enabled : true Warning Use this configuration for dev purposes only!","title":"Configuration"},{"location":"watch_server/#watch","text":"There is then a new command to start the watch server: bin/console event-sourcing:watch Note The command can be terminated with ctrl+c or control+c .","title":"Watch"}]}