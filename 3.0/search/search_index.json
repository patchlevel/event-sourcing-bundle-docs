{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Event-Sourcing-Bundle","text":"<p>A lightweight but also all-inclusive event sourcing bundle  with a focus on developer experience and based on doctrine dbal. This bundle is a symfony integration  for event-sourcing library.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Everything is included in the package for event sourcing</li> <li>Based on doctrine dbal and their ecosystem</li> <li>Developer experience oriented and fully typed</li> <li>Snapshots system to quickly rebuild the aggregates</li> <li>Pipeline to build new projections or to migrate events</li> <li>Scheme management and doctrine migration support</li> <li>Dev tools such as a realtime event watcher</li> <li>Built in cli commands with symfony</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>composer require patchlevel/event-sourcing-bundle\n</code></pre> <p>Warning</p> <p>If you don't use the symfony flex recipe for this bundle, you need to follow this installation documentation.</p>"},{"location":"#integration","title":"Integration","text":"<ul> <li>Psalm</li> </ul>"},{"location":"aggregate/","title":"Aggregate","text":"<p>Info</p> <p>You can find out more about aggregates in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"aggregate/#register-aggregates","title":"Register aggregates","text":"<p>A path must be specified for Event Sourcing to know where to look for your aggregates.</p> <pre><code>patchlevel_event_sourcing:\n  aggregates: '%kernel.project_dir%/src'\n</code></pre> <p>Tip</p> <p>You can also define multiple paths by specifying an array.</p>"},{"location":"aggregate/#define-aggregates","title":"Define aggregates","text":"<p>Next, you need to create a class to serve as an aggregate.  In our example it is a hotel. This class must inherit from <code>AggregateRoot</code> and get the <code>Aggregate</code> attribute.</p> <pre><code>namespace App\\Domain\\Hotel;\n\nuse Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\n\n#[Aggregate(name: 'hotel')]\nfinal class Hotel extends AggregateRoot\n{\n    // ...\n}\n</code></pre> <p>Note</p> <p>You should read here how the aggregates then work internally.</p>"},{"location":"cli/","title":"CLI","text":"<p>The bundle also offers <code>cli commands</code> to create or delete <code>databases</code>.  It is also possible to manage the <code>schema</code> and <code>projections</code>.</p>"},{"location":"cli/#database-commands","title":"Database commands","text":"<p>There are two commands for creating and deleting a database.</p> <ul> <li><code>event-sourcing:database:create</code></li> <li><code>event-sourcing:database:drop</code></li> </ul>"},{"location":"cli/#schema-commands","title":"Schema commands","text":"<p>The database schema can also be created, updated and dropped.</p> <ul> <li><code>event-sourcing:schema:create</code></li> <li><code>event-sourcing:schema:update</code></li> <li><code>event-sourcing:schema:drop</code></li> </ul> <p>Note</p> <p>You can also register doctrine migration commands, see the store documentation for this.</p>"},{"location":"cli/#projection-commands","title":"Projection commands","text":"<p>The creation, deletion and rebuilding of the projections is also possible via the cli.</p> <ul> <li><code>event-sourcing:projection:create</code></li> <li><code>event-sourcing:projection:drop</code></li> <li><code>event-sourcing:projection:rebuild</code></li> </ul> <p>Note</p> <p>The pipeline will be used to rebuild the projection.</p>"},{"location":"clock/","title":"Clock","text":"<p>The clock is used to return the current time as DateTimeImmutable.  There is a system clock and a frozen clock for test purposes.</p> <p>Info</p> <p>You can find out more about clock in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"clock/#testing","title":"Testing","text":"<p>You can freeze the clock for testing purposes:</p> <pre><code>when@test:\n    patchlevel_event_sourcing:\n        clock:\n            freeze: '2020-01-01 22:00:00'\n</code></pre> <p>Note</p> <p>If freeze is not set, then the system clock is used.</p>"},{"location":"clock/#psr-20","title":"PSR-20","text":"<p>You can also use your own implementation of your choice.  They only have to implement the interface of the psr-20.  You can then specify this service here:</p> <pre><code>patchlevel_event_sourcing:\n    clock:\n        service: 'my_own_clock_service'\n</code></pre>"},{"location":"clock/#symfony-clock","title":"Symfony Clock","text":"<p>Since symfony 6.2 there is a clock implementation  based on psr-20 that you can use.</p> <pre><code>composer require symfony/clock\n</code></pre> <pre><code>patchlevel_event_sourcing:\n    clock:\n        service: 'clock'\n</code></pre>"},{"location":"event_bus/","title":"Event Bus","text":"<p>This library uses the core principle called event bus.</p> <p>For all events that are persisted (when the <code>save</code> method has been executed on the repository), the event will be dispatched to the <code>event bus</code>. All listeners are then called for each event.</p> <p>Info</p> <p>You can find out more about the event bus in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"event_bus/#symfony-event-bus","title":"Symfony Event Bus","text":"<p>To use the Symfony Messager,  you have to define it in messenger.yaml. It's best to call the bus \"event.bus\". An event bus can have 0 or n listener for an event.  So \"allow_no_handlers\" has to be configured.</p> <pre><code>framework:\n    messenger:\n        buses:\n            event.bus:\n                default_middleware: allow_no_handlers\n</code></pre> <p>We can then use this message or event bus in event sourcing:</p> <pre><code>patchlevel_event_sourcing:\n    event_bus:\n        service: event.bus\n</code></pre>"},{"location":"event_bus/#command-bus","title":"Command Bus","text":"<p>If you use a command bus or cqrs as a pattern, then you should define a new message bus.  The whole thing can look like this:</p> <pre><code>framework:\n    messenger:\n        default_bus: command.bus\n        buses:\n            command.bus: ~\n            event.bus:\n                default_middleware: allow_no_handlers\n</code></pre> <p>Warning</p> <p>You should deactivate the autoconfigure feature for the handlers,  otherwise they will be registered in both handlers.</p>"},{"location":"events/","title":"Events","text":"<p>Events are used to describe things that happened in the application.  Since the events already happened, they are also immutable.  In event sourcing, these are used to save and rebuild the current state.  You can also listen on events to react and perform different actions.</p> <p>Info</p> <p>You can find out more about events in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"events/#register-events","title":"Register events","text":"<p>A path must be specified for Event Sourcing to know where to look for your evets.</p> <pre><code>patchlevel_event_sourcing:\n  events: '%kernel.project_dir%/src'\n</code></pre> <p>Tip</p> <p>You can also define multiple paths by specifying an array.</p>"},{"location":"events/#define-events","title":"Define events","text":"<p>Next, you need to create a class to serve as an event. This class must get the <code>Event</code> attribute with a unique event name.</p> <pre><code>namespace App\\Domain\\Hotel\\Event;\n\nuse Patchlevel\\EventSourcing\\Attribute\\Event;\nuse Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer;\nuse Symfony\\Component\\Uid\\Uuid;\n\n#[Event('hotel.created')]\nfinal class HotelCreated\n{\n    public function __construct(\n        #[UuidNormalizer]\n        public readonly Uuid $id, \n        public readonly string $hotelName\n    ) {\n    }\n}\n</code></pre> <p>Note</p> <p>If you want to learn more about events, read the library documentation.</p> <p>Note</p> <p>You can read more about normalizer here.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out.</p> <p>For this example we use following package:</p> <ul> <li>symfony/mailer</li> </ul>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>First of all, the bundle has to be installed and configured.  If you haven't already done so, see the installation introduction.</p>"},{"location":"getting_started/#define-some-events","title":"Define some events","text":"<p>First we define the events that happen in our system.</p> <p>A hotel can be created with a <code>name</code>:</p> <pre><code>namespace App\\Domain\\Hotel\\Event;\n\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Event;\nuse Patchlevel\\EventSourcing\\Serializer\\Normalizer\\IdNormalizer;\n\n#[Event('hotel.created')]\nfinal class HotelCreated\n{\n    public function __construct(\n        #[IdNormalizer(Uuid::class)]\n        public readonly Uuid $id, \n        public readonly string $hotelName\n    ) {\n    }\n}\n</code></pre> <p>A guest can check in by name:</p> <pre><code>namespace App\\Domain\\Hotel\\Event;\n\nuse Patchlevel\\EventSourcing\\Attribute\\Event;\n\n#[Event('hotel.guest_is_checked_in')]\nfinal class GuestIsCheckedIn\n{\n    public function __construct(\n        public readonly string $guestName\n    ) {\n    }\n}\n</code></pre> <p>And also check out again:</p> <pre><code>namespace App\\Domain\\Hotel\\Event;\n\nuse Patchlevel\\EventSourcing\\Attribute\\Event;\n\n#[Event('hotel.guest_is_checked_out')]\nfinal class GuestIsCheckedOut\n{\n    public function __construct(\n        public readonly string $guestName\n    ) {\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about events here.</p>"},{"location":"getting_started/#define-aggregates","title":"Define aggregates","text":"<p>Next we need to define the aggregate. So the hotel and how the hotel should behave.  We have also defined the <code>create</code>, <code>checkIn</code> and <code>checkOut</code> methods accordingly.  These events are thrown here and the state of the hotel is also changed.</p> <pre><code>namespace App\\Domain\\Hotel;\n\nuse App\\Domain\\Hotel\\Event\\HotelCreated;\nuse App\\Domain\\Hotel\\Event\\GuestIsCheckedIn;\nuse App\\Domain\\Hotel\\Event\\GuestIsCheckedOut;\nuse Patchlevel\\EventSourcing\\Aggregate\\BasicAggregateRoot;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Apply;\nuse Patchlevel\\EventSourcing\\Attribute\\Id;\n\n#[Aggregate(name: 'hotel')]\nfinal class Hotel extends BasicAggregateRoot\n{\n    #[Id]\n    private Uuid $id;\n    private string $name;\n\n    /**\n     * @var list&lt;string&gt;\n     */\n    private array $guests;\n\n    public function name(): string\n    {\n        return $this-&gt;name;\n    }\n\n    public function guests(): array\n    {\n        return $this-&gt;guests;\n    }\n\n    public static function create(Uuid $id, string $hotelName): self\n    {\n        $self = new self();\n        $self-&gt;recordThat(new HotelCreated($id, $hotelName));\n\n        return $self;\n    }\n\n    public function checkIn(string $guestName): void\n    {\n        if (in_array($guestName, $this-&gt;guests, true)) {\n            throw new GuestHasAlreadyCheckedIn($guestName);\n        }\n\n        $this-&gt;recordThat(new GuestIsCheckedIn($guestName));\n    }\n\n    public function checkOut(string $guestName): void\n    {\n        if (!in_array($guestName, $this-&gt;guests, true)) {\n            throw new IsNotAGuest($guestName);\n        }\n\n        $this-&gt;recordThat(new GuestIsCheckedOut($guestName));\n    }\n\n    #[Apply]\n    protected function applyHotelCreated(HotelCreated $event): void\n    {\n        $this-&gt;id = $event-&gt;id;\n        $this-&gt;name = $event-&gt;hotelName;\n        $this-&gt;guests = [];      \n    }\n\n    #[Apply]\n    protected function applyGuestIsCheckedIn(GuestIsCheckedIn $event): void\n    {\n        $this-&gt;guests[] = $event-&gt;guestName;\n    }\n\n    #[Apply]\n    protected function applyGuestIsCheckedOut(GuestIsCheckedOut $event): void\n    {\n        $this-&gt;guests = array_values(\n            array_filter(\n                $this-&gt;guests,\n                fn($name) =&gt; $name !== $event-&gt;guestName\n            )\n        );\n    }\n}\n</code></pre> <p>Note</p> <p>You can find out more about aggregates here.</p>"},{"location":"getting_started/#define-projections","title":"Define projections","text":"<p>So that we can see all the hotels on our website  and also see how many guests are currently visiting the hotels,  we need a projection for it.</p> <pre><code>namespace App\\Projection;\n\nuse App\\Domain\\Hotel\\Event\\HotelCreated;\nuse App\\Domain\\Hotel\\Event\\GuestIsCheckedIn;\nuse App\\Domain\\Hotel\\Event\\GuestIsCheckedOut;\nuse Doctrine\\DBAL\\Connection;\nuse Patchlevel\\EventSourcing\\Attribute\\Setup;\nuse Patchlevel\\EventSourcing\\Attribute\\Teardown;\nuse Patchlevel\\EventSourcing\\Attribute\\Subscribe;\nuse Patchlevel\\EventSourcing\\Attribute\\Projector;\nuse Patchlevel\\EventSourcing\\EventBus\\Message;\nuse Patchlevel\\EventSourcing\\Projection\\Projector\\ProjectorUtil;\n\n#[Projector('hotel')]\nfinal class HotelProjection\n{\n    use ProjectorUtil;\n\n    private Connection $db;\n\n    public function __construct(Connection $db)\n    {\n        $this-&gt;db = $db;\n    }\n\n    /**\n     * @return list&lt;array{id: string, name: string, guests: int}&gt;\n     */\n    public function getHotels(): array \n    {\n        return $this-&gt;db-&gt;fetchAllAssociative(\"SELECT id, name, guests FROM ${this-&gt;table()};\");\n    }\n\n    #[Subscribe(HotelCreated::class)]\n    public function handleHotelCreated(Message $message): void\n    {\n        $this-&gt;db-&gt;insert(\n            $this-&gt;table(), \n            [\n                'id' =&gt; $message-&gt;aggregateId(), \n                'name' =&gt; $message-&gt;event()-&gt;hotelName,\n                'guests' =&gt; 0\n            ]\n        );\n    }\n\n    #[Subscribe(GuestIsCheckedIn::class)]\n    public function handleGuestIsCheckedIn(Message $message): void\n    {\n        $this-&gt;db-&gt;executeStatement(\n            \"UPDATE ${this-&gt;table()} SET guests = guests + 1 WHERE id = ?;\",\n            [$message-&gt;aggregateId()]\n        );\n    }\n\n    #[Subscribe(GuestIsCheckedOut::class)]\n    public function handleGuestIsCheckedOut(Message $message): void\n    {\n        $this-&gt;db-&gt;executeStatement(\n            \"UPDATE ${this-&gt;table()} SET guests = guests - 1 WHERE id = ?;\",\n            [$message-&gt;aggregateId()]\n        );\n    }\n\n    #[Setup]\n    public function create(): void\n    {\n        $this-&gt;db-&gt;executeStatement(\"CREATE TABLE IF NOT EXISTS ${this-&gt;table()} (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);\");\n    }\n\n    #[Teardown]\n    public function drop(): void\n    {\n        $this-&gt;db-&gt;executeStatement(\"DROP TABLE IF EXISTS ${this-&gt;table()};\");\n    }\n\n    private function table(): string \n    {\n        return sprintf('%s_%s', $this-&gt;projectionName(), $this-&gt;projectionVersion());\n    }\n}\n</code></pre> <p>Warning</p> <p>autoconfigure need to be enabled, otherwise you need add the <code>event_sourcing.projector</code> tag.</p> <p>Note</p> <p>You can find out more about projections here.</p>"},{"location":"getting_started/#processor","title":"Processor","text":"<p>In our example we also want to send an email to the head office as soon as a guest is checked in.</p> <pre><code>namespace App\\Domain\\Hotel\\Listener;\n\nuse App\\Domain\\Hotel\\Event\\GuestIsCheckedIn;\nuse Patchlevel\\EventSourcing\\EventBus\\Message;\nuse Patchlevel\\EventSourcing\\EventBus\\Subscriber;\nuse Patchlevel\\EventSourcingBundle\\Attribute\\AsProcessor;\nuse Symfony\\Component\\Mailer\\MailerInterface;\nuse Symfony\\Component\\Mime\\Email;\n\n#[AsProcessor]\nfinal class SendCheckInEmailListener\n{\n    private function __construct(\n        private readonly MailerInterface $mailer\n    ) \n    {\n    }\n\n    #[Subscribe(GuestIsCheckedIn::class)]\n    public function onGuestIsCheckedIn(Message $message): void\n    {\n        $event = $message-&gt;event();\n\n        $email = (new Email())\n            -&gt;from('noreply@patchlevel.de')\n            -&gt;to('hq@patchlevel.de')\n            -&gt;subject('Guest is checked in')\n            -&gt;text(sprintf('A new guest named \"%s\" is checked in', $event-&gt;guestName));\n\n        $this-&gt;mailer-&gt;send($email);\n    }\n}\n</code></pre> <p>Warning</p> <p>autoconfigure need to be enabled, otherwise you need add the <code>event_sourcing.processor</code> tag.</p> <p>Note</p> <p>You can find out more about processor here.</p>"},{"location":"getting_started/#database-setup","title":"Database setup","text":"<p>So that we can actually write the data to a database, we need the associated schema and databases.</p> <pre><code>bin/console event-sourcing:database:create\nbin/console event-sourcing:schema:create\nbin/console event-sourcing:projection:boot\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>We are now ready to use the Event Sourcing System. We can load, change and save aggregates.</p> <pre><code>namespace App\\Controller;\n\nuse App\\Domain\\Hotel\\Hotel;\nuse App\\Projection\\HotelProjection;\nuse Patchlevel\\EventSourcing\\Aggregate\\Uuid;\nuse Patchlevel\\EventSourcing\\Repository\\Repository;\nuse Patchlevel\\EventSourcing\\Repository\\RepositoryManager;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Attribute\\AsController;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n#[AsController]\nfinal class HotelController\n{\n    /** @var Repository&lt;Hotel&gt; */\n    private Repository $hotelRepository;\n    private HotelProjection $hotelProjection;\n\n    public function __construct(\n        RepositoryManager $repositoryManager,\n        HotelProjection $hotelProjection\n    ) {\n        $this-&gt;hotelRepository = $repositoryManager-&gt;get(Hotel::class);\n        $this-&gt;hotelProjection = $hotelProjection;\n    }\n\n    #[Route(\"/\", methods:[\"GET\"])]\n    public function listAction(): JsonResponse\n    {\n        return new JsonResponse(\n            $this-&gt;hotelProjection-&gt;getHotels()\n        );\n    }\n\n    #[Route(\"/create\", methods:[\"POST\"])]\n    public function createAction(Request $request): JsonResponse\n    {\n        $hotelName = $request-&gt;request-&gt;get('name'); // need validation!\n        $id = Uuid::v7();\n\n        $hotel = Hotel::create($id, $hotelName);\n        $this-&gt;hotelRepository-&gt;save($hotel);\n\n        return new JsonResponse(['id' =&gt; $id-&gt;jsonSerialize()]);\n    }\n\n    #[Route(\"/{hotel}/check-in\", methods:[\"POST\"])]\n    public function checkInAction(string $hotel, Request $request): JsonResponse\n    {\n        $id = Uuid::fromString($hotel);\n        $guestName = $request-&gt;request-&gt;get('name'); // need validation!\n\n        $hotel = $this-&gt;hotelRepository-&gt;load((string)$id);\n        $hotel-&gt;checkIn($guestName);\n        $this-&gt;hotelRepository-&gt;save($hotel);\n\n        return new JsonResponse();\n    }\n\n    #[Route(\"/{hotel}/check-out\", methods:[\"POST\"])]\n    public function checkOutAction(string $hotel, Request $request): JsonResponse\n    {\n        $id = Uuid::fromString($hotel);\n        $guestName = $request-&gt;request-&gt;get('name'); // need validation!\n\n        $hotel = $this-&gt;hotelRepository-&gt;load((string)$id);\n        $hotel-&gt;checkOut($guestName);\n        $this-&gt;hotelRepository-&gt;save($hotel);\n\n        return new JsonResponse();\n    }\n}\n</code></pre> <p>Note</p> <p>You can also use a command bus.</p>"},{"location":"installation/","title":"Installation","text":"<p>If you are not using a symfony flex  or the recipes for it,  then you have to carry out a few installation steps by hand.</p>"},{"location":"installation/#require-package","title":"Require package","text":"<p>The first thing to do is to install packet if it has not already been done.</p> <pre><code>composer require patchlevel/event-sourcing-bundle\n</code></pre> <p>Note</p> <p>how to install composer</p>"},{"location":"installation/#enable-bundle","title":"Enable bundle","text":"<p>Then we have to activate the bundle in the <code>config/bundles.php</code>:</p> <pre><code>return [\n    Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle::class =&gt; ['all' =&gt; true],\n];\n</code></pre> <p>If you don't have <code>config/bundles.php</code> then you need to add the bundle in the kernel:</p> <pre><code>class AppKernel extends Kernel\n{\n    public function registerBundles()\n    {\n        $bundles = [\n            new Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle(),\n        ];\n    }\n}\n</code></pre>"},{"location":"installation/#configuration-file","title":"Configuration file","text":"<p>Now you have to add a minimal configuration file here <code>config/packages/patchlevel_event_sourcing.yaml</code>.</p> <pre><code>patchlevel_event_sourcing:\n    aggregates: '%kernel.project_dir%/src'\n    events: '%kernel.project_dir%/src'\n    connection:\n        url: '%env(EVENTSTORE_URL)%'\n</code></pre>"},{"location":"installation/#dotenv","title":"Dotenv","text":"<p>Finally we have to fill the ENV variable with a connection url.</p> <pre><code>EVENTSTORE_URL=mysql://user:secret@localhost/app\n</code></pre> <p>Note</p> <p>You can find out more about what a connection url looks like here.</p> <p>Now you can go back to getting started.</p>"},{"location":"message_decorator/","title":"Message Decorator","text":"<p>There are usecases where you want to add some extra context to your events like metadata which is not directly relevant for your domain. With <code>MessageDecorator</code> we are providing a solution to add this metadata to your events. The metadata will also be persisted in the database and can be retrieved later on.</p> <p>Info</p> <p>You can find out more about message decorator in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"message_decorator/#usage","title":"Usage","text":"<p>We want to add the header information which user was logged in when this event was generated.</p> <pre><code>use Patchlevel\\EventSourcing\\EventBus\\Message;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\n\nfinal class LoggedUserDecorator implements MessageDecorator\n{\n    public function __construct(\n        private readonly TokenStorageInterface $tokenStorage\n    ) {}\n\n    public function __invoke(Message $message): Message\n    {\n        $token = $this-&gt;tokenStorage-&gt;getToken();\n\n        if (!$token) {\n            return;\n        }\n\n        return $message-&gt;withCustomHeader('user', $token-&gt;getUserIdentifier());\n    }\n} \n</code></pre> <p>If you have the symfony default service setting with <code>autowire</code>and <code>autoconfigure</code> enabled, the message decorator is automatically recognized and registered at the <code>MessageDecorator</code> interface. Otherwise you have to define the message decorator in the symfony service file:</p> <pre><code>services:\n  App\\Message\\Decorator\\LoggedUserDecorator:\n    tags:\n      - event_sourcing.message_decorator\n</code></pre>"},{"location":"migration/","title":"Migration","text":"<p>You can use doctrine migration, which is known from doctrine orm, to create your schema and keep it in sync.</p> <p>Info</p> <p>You can find out more about migration in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"migration/#installation","title":"Installation","text":"<p>In order to be able to use <code>doctrine/migrations</code>, you have to install the associated package.</p> <pre><code>composer require doctrine/migrations\n</code></pre>"},{"location":"migration/#migration-commands","title":"Migration commands","text":"<p>After the migration lib has been installed, the migration commands are automatically configured:</p> <ul> <li>ExecuteCommand: <code>event-sourcing:migrations:execute</code></li> <li>GenerateCommand: <code>event-sourcing:migrations:generate</code></li> <li>LatestCommand: <code>event-sourcing:migrations:latest</code></li> <li>ListCommand: <code>event-sourcing:migrations:list</code></li> <li>MigrateCommand: <code>event-sourcing:migrations:migrate</code></li> <li>DiffCommand: <code>event-sourcing:migrations:diff</code></li> <li>StatusCommand: <code>event-sourcing:migrations:status</code></li> <li>VersionCommand: <code>event-sourcing:migrations:version</code></li> </ul>"},{"location":"migration/#configure","title":"Configure","text":"<p>You can also configure the migration integration.  Here is an example with the default values:</p> <pre><code>patchlevel_event_sourcing:\n    migration:\n        namespace: 'EventSourcingMigrations'\n        path: '%kernel.project_dir%/migrations'\n</code></pre>"},{"location":"normalizer/","title":"Normalizer","text":"<p>Sometimes you also want to add more complex data in events as payload or in aggregates for the snapshots.  For example DateTime, enums or value objects. You can do that too.  However, you must define a normalizer for this so that the library knows how to write this data to the database  and load it again.</p> <p>Info</p> <p>You can find out more about normalizer in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"normalizer/#built-in-normalizer","title":"Built-in Normalizer","text":"<p>This bundle adds more Symfony specific normalizers in addition to the existing built-in normalizers.</p> <p>Note</p> <p>You can find the other build-in normalizers here</p>"},{"location":"normalizer/#uuid","title":"Uuid","text":"<p>With the <code>Uuid</code> Normalizer, as the name suggests, you can convert Symfony Uuid objects to a string and back again.</p> <pre><code>use Patchlevel\\EventSourcing\\Attribute\\Normalize;\nuse Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer;\nuse Symfony\\Component\\Uid\\Uuid;\n\nfinal class DTO \n{\n    #[UuidNormalizer]\n    public Uuid $id;\n}\n</code></pre>"},{"location":"pipeline/","title":"Pipeline","text":"<p>A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them.</p> <p>Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked.</p> <p>Info</p> <p>You can find out more about pipeline in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"pipeline/#example","title":"Example","text":"<p>In this example the event <code>PrivacyAdded</code> is removed and the event <code>OldVisited</code> is replaced by <code>NewVisited</code>:</p> <pre><code>namespace App\\Command;\n\nuse Doctrine\\DBAL\\Connection;\nuse Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware;\nuse Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware;\nuse Patchlevel\\EventSourcing\\Pipeline\\Pipeline;\nuse Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource;\nuse Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget;\nuse Patchlevel\\EventSourcing\\Serializer\\Serializer;use Patchlevel\\EventSourcing\\Store\\MultiTableStore;\nuse Patchlevel\\EventSourcing\\Store\\Store;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\nuse Symfony\\Component\\Console\\Style\\SymfonyStyle;\n\nclass CreateUserCommand extends Command\n{\n    protected static $defaultName = 'app:event-sourcing:migrate-db-v2';\n\n    private Store $oldStore;\n    private Connection $newConnection;\n    private Serializer $serializer;\n    private AggregateRootRegistry $aggregateRegistry;\n\n    public function __construct(\n        Store $oldStore, \n        Connection $newConnection,\n        Serializer $serializer,\n        AggregateRootRegistry $aggregateRegistry\n    ) {\n        $this-&gt;oldStore = $oldStore;\n        $this-&gt;newConnection = $newConnection;\n        $this-&gt;serializer = $serializer;\n        $this-&gt;aggregateRegistry = $aggregateRegistry;\n\n        parent::__construct();\n    }\n\n    protected function configure(): void\n    {\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $console = new SymfonyStyle($input, $output);\n\n        $newStore = new MultiTableStore(\n            $this-&gt;newConnection, \n            $this-&gt;serializer,\n            $this-&gt;aggregateRegistry\n        );\n\n        $pipeline = new Pipeline(\n            new StoreSource($oldStore),\n            new StoreTarget($newStore),\n            [\n                new ExcludeEventMiddleware([PrivacyAdded::class]),\n                new ReplaceEventMiddleware(OldVisited::class, static function (OldVisited $oldVisited) {\n                    return NewVisited::raise($oldVisited-&gt;profileId());\n                }),\n                new RecalculatePlayheadMiddleware(),\n            ]\n        );\n\n        $console-&gt;progressStart($pipeline-&gt;count());\n\n        $pipeline-&gt;run(static function () use ($console): void {\n            $console-&gt;progressAdvance();\n        });\n\n        $console-&gt;progressFinish();\n        $console-&gt;success('finish');\n\n        return Command::SUCCESS;\n    }\n}\n</code></pre> <p>The whole thing just has to be plugged together.</p> <pre><code>services:\n  App\\Command\\CreateUserCommand:\n    arguments:\n      newConnection: '@doctrine.dbal.new_connection'\n</code></pre> <p>Note</p> <p>If you have the doctrine bundle for the dbal connections,  then you can autowire it.</p>"},{"location":"processor/","title":"Processor","text":"<p>The <code>processor</code> is a kind of event bus listener that can execute actions on certain events.</p> <p>Info</p> <p>You can find out more about processor in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"processor/#usage","title":"Usage","text":"<p>A process can be for example used to send an email when a guest is checked in:</p> <pre><code>namespace App\\Domain\\Hotel\\Listener;\n\nuse App\\Domain\\Hotel\\Event\\GuestIsCheckedIn;\nuse Patchlevel\\EventSourcing\\Attribute\\Subscribe;\nuse Patchlevel\\EventSourcing\\EventBus\\Message;\nuse Patchlevel\\EventSourcingBundle\\Attribute\\AsProcessor;\nuse Symfony\\Component\\Mailer\\MailerInterface;\nuse Symfony\\Component\\Mime\\Email;\n\n#[AsProcessor]\nfinal class SendCheckInEmailListener\n{\n    private MailerInterface $mailer;\n\n    private function __construct(MailerInterface $mailer) \n    {\n        $this-&gt;mailer = $mailer;\n    }\n\n    #[Subscribe]\n    public function __invoke(Message $message): void\n    {\n        $event = $message-&gt;event();\n\n        if (!$event instanceof GuestIsCheckedIn) {\n            return;\n        }\n\n        $email = (new Email())\n            -&gt;from('noreply@patchlevel.de')\n            -&gt;to('hq@patchlevel.de')\n            -&gt;subject('Guest is checked in')\n            -&gt;text(sprintf('A new guest named \"%s\" is checked in', $event-&gt;guestName()));\n\n        $this-&gt;mailer-&gt;send($email);\n    }\n}\n</code></pre> <p>If you have the symfony default service setting with <code>autowire</code>and <code>autoconfiger</code> enabled,  the processor is automatically recognized and registered at the <code>AsProcessor</code> attribute.  Otherwise you have to define the processor in the symfony service file:</p> <pre><code>services:\n    App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener:\n      tags:\n        - event_sourcing.processor\n</code></pre>"},{"location":"processor/#priority","title":"Priority","text":"<p>You can also determine the <code>priority</code> in which the processors are executed.  The higher the priority, the earlier the processor is executed.  You have to add the tag manually and specify the priority.</p> <pre><code>namespace App\\Domain\\Hotel\\Listener;\n\n#[AsProcessor(priority: 16)]\nfinal class SendCheckInEmailListener\n{\n    // ...\n}\n</code></pre> <pre><code>services:\n    App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener:\n      autoconfigure: false\n      tags:\n        - name: event_sourcing.processor\n          priority: 16\n</code></pre> <p>Warning</p> <p>You have to deactivate the <code>autoconfigure</code> for this service,  otherwise the service will be added twice.</p>"},{"location":"projection/","title":"Projection","text":"<p>With <code>projections</code> you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events.</p> <p>The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch.</p> <p>Info</p> <p>You can find out more about projection in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"projection/#define-projection","title":"Define Projection","text":"<p>In this example we are simply mapping hotel statistics:</p> <pre><code>namespace App\\Projection;\n\nuse App\\Domain\\Hotel\\Event\\HotelCreated;\nuse App\\Domain\\Hotel\\Event\\GuestIsCheckedIn;\nuse App\\Domain\\Hotel\\Event\\GuestIsCheckedOut;\nuse Doctrine\\DBAL\\Connection;\nuse Patchlevel\\EventSourcing\\Attribute\\Create;\nuse Patchlevel\\EventSourcing\\Attribute\\Drop;\nuse Patchlevel\\EventSourcing\\Attribute\\Handle;\nuse Patchlevel\\EventSourcing\\EventBus\\Message;\nuse Patchlevel\\EventSourcing\\Projection\\Projector\\Projector;\n\nfinal class HotelProjection implements Projector\n{\n    private Connection $db;\n\n    public function __construct(Connection $db)\n    {\n        $this-&gt;db = $db;\n    }\n\n    /**\n     * @return list&lt;array{id: string, name: string, guests: int}&gt;\n     */\n    public function getHotels(): array \n    {\n        return $this-&gt;db-&gt;fetchAllAssociative('SELECT id, name, guests FROM hotel;')\n    }\n\n    #[Handle(HotelCreated::class)]\n    public function handleHotelCreated(Message $message): void\n    {\n        $event = $message-&gt;event();\n\n        $this-&gt;db-&gt;insert(\n            'hotel', \n            [\n                'id' =&gt; $event-&gt;aggregateId(), \n                'name' =&gt; $event-&gt;hotelName(),\n                'guests' =&gt; 0\n            ]\n        );\n    }\n\n    #[Handle(GuestIsCheckedIn::class)]\n    public function handleGuestIsCheckedIn(Message $message): void\n    {\n        $event = $message-&gt;event();\n\n        $this-&gt;db-&gt;executeStatement(\n            'UPDATE hotel SET guests = guests + 1 WHERE id = ?;',\n            [$event-&gt;aggregateId()]\n        );\n    }\n\n    #[Handle(GuestIsCheckedOut::class)]\n    public function handleGuestIsCheckedOut(Message $message): void\n    {\n        $event = $message-&gt;event();\n\n        $this-&gt;db-&gt;executeStatement(\n            'UPDATE hotel SET guests = guests - 1 WHERE id = ?;',\n            [$event-&gt;aggregateId()]\n        );\n    }\n\n    #[Create]\n    public function create(): void\n    {\n        $this-&gt;db-&gt;executeStatement('CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);');\n    }\n\n    #[Drop]\n    public function drop(): void\n    {\n        $this-&gt;db-&gt;executeStatement('DROP TABLE IF EXISTS hotel;');\n    }\n}\n</code></pre> <p>If you have the symfony default service setting with <code>autowire</code>and <code>autoconfigure</code> enabled, the projection is automatically recognized and registered at the <code>Projector</code> interface. Otherwise you have to define the projection in the symfony service file:</p> <pre><code>services:\n    App\\Projection\\HotelProjection:\n      tags:\n        - event_sourcing.projector\n</code></pre>"},{"location":"projection/#projection-commands","title":"Projection commands","text":"<p>The bundle also provides a few commands to create, delete or rebuild projections:</p> <pre><code>bin/console event-sourcing:projection:create\nbin/console event-sourcing:projection:drop\nbin/console event-sourcing:projection:rebuild\n</code></pre>"},{"location":"repository/","title":"Repository","text":"<p>A <code>repository</code> takes care of storing and loading the <code>aggregates</code>. The design pattern of the same name is also used.</p> <p>Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate.</p> <p>Info</p> <p>You can find out more about repository in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"repository/#use-repositories","title":"Use repositories","text":"<p>You can access the specific repositories using the <code>RepositoryManager</code>.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\RepositoryManager;\n\nfinal class HotelController\n{    \n    public function doStuffAction(RepositoryManager $repositoryManager): Response\n    {\n        $hotelRepository = $repositoryManager-&gt;get(Hotel::class);\n        $hotel = $hotelRepository-&gt;load('1');\n\n        $hotel-&gt;doStuff();\n\n        $hotelRepository-&gt;save($hotel);\n\n        // ...\n    }\n}\n</code></pre>"},{"location":"repository/#custom-repositories","title":"Custom Repositories","text":"<p>In clean code you want to have explicit type hints for the repositories so that you don't accidentally use the wrong repository. It would also help in frameworks with a dependency injection container, as this allows the services to be autowired. However, you cannot inherit from our repository implementations. Instead, you just have to wrap these repositories. This also gives you more type security.</p> <pre><code>use Patchlevel\\EventSourcing\\Repository\\Repository;\nuse Patchlevel\\EventSourcing\\Repository\\RepositoryManager;\n\nclass HotelRepository \n{\n    /** @var Repository&lt;Hotel&gt;  */\n    private Repository $repository;\n\n    public function __construct(RepositoryManager $repositoryManager) \n    {\n        $this-&gt;repository = $repositoryManager-&gt;get(Hotel::class);\n    }\n\n    public function load(HotelId $id): Hotel \n    {\n        return $this-&gt;repository-&gt;load($id-&gt;toString());\n    }\n\n    public function save(Hotel $hotel): void \n    {\n        return $this-&gt;repository-&gt;save($hotel);\n    }\n\n    public function has(HotelId $id): bool \n    {\n        return $this-&gt;repository-&gt;has($id-&gt;toString());\n    }\n}\n</code></pre>"},{"location":"snapshots/","title":"Snapshots","text":"<p>Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The <code>snapshot</code> system can be used to control this.</p> <p>Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a <code>snapshot</code>, we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all.</p> <p>Info</p> <p>You can find out more about snapshots in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"snapshots/#using-symfony-cache","title":"Using Symfony Cache","text":"<p>You can use symfony cache to define the target of the snapshot store.</p> <pre><code>framework:\n    cache:\n        default_redis_provider: 'redis://localhost'\n        pools:\n            event_sourcing.cache:\n                adapter: cache.adapter.redis\n</code></pre> <p>After this, you need define the snapshot store.  Symfony cache implement the psr6 interface, so we need choose this type and enter the id from the cache service.</p> <pre><code>patchlevel_event_sourcing:\n    snapshot_stores:\n        default:\n            service: event_sourcing.cache\n</code></pre> <p>Finally, you have to tell the aggregate that it should use this snapshot store.</p> <pre><code>namespace App\\Domain\\Profile;\n\nuse Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Snapshot;\n\n#[Aggregate(name: 'profile')]\n#[Snapshot('default')]\nfinal class Profile extends AggregateRoot\n{\n    // ...\n}\n</code></pre> <p>Book</p> <p>You can find out more about the attributes here.</p>"},{"location":"snapshots/#batch","title":"Batch","text":"<p>So that not every write process also writes to the cache at the same time,  you can also say from how many events should be written to the snapshot store first.  This minimizes the write operations to the cache, which improves performance.</p> <pre><code>namespace App\\Domain\\Profile;\n\nuse Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot;\nuse Patchlevel\\EventSourcing\\Attribute\\Aggregate;\nuse Patchlevel\\EventSourcing\\Attribute\\Snapshot;\n\n#[Aggregate(name: 'profile')]\n#[Snapshot('default', batch: 1000)]\nfinal class Profile extends AggregateRoot\n{\n    // ...\n}\n</code></pre>"},{"location":"store/","title":"Store","text":"<p>In the end, the events have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies.</p> <p>Info</p> <p>You can find out more about stores in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"store/#manage-database-and-schema","title":"Manage database and schema","text":"<p>The bundle provides you with a few <code>commands</code> with which you can create and delete the <code>database</code>.  You can also use it to create, edit and delete the <code>schema</code>.</p>"},{"location":"store/#create-and-drop-database","title":"Create and drop database","text":"<pre><code>bin/console event-sourcing:database:create\nbin/console event-sourcing:database:drop\n</code></pre>"},{"location":"store/#create-update-and-drop-schema","title":"Create, update and drop schema","text":"<pre><code>bin/console event-sourcing:schema:create\nbin/console event-sourcing:schema:udapte\nbin/console event-sourcing:schema:drop\n</code></pre>"},{"location":"store/#use-doctrine-connection","title":"Use doctrine connection","text":"<p>If you have installed the doctrine bundle,  you can also define the connection via doctrine and then use it in the store.</p> <pre><code>doctrine:\n    dbal:\n        connections:\n            eventstore:\n                url: '%env(EVENTSTORE_URL)%'\n\npatchlevel_event_sourcing:\n    connection:\n        service: doctrine.dbal.eventstore_connection\n</code></pre> <p>Warning</p> <p>If you want to use the same connection as doctrine orm, then you have to set the flag <code>merge_orm_schema</code>.  Otherwise you should avoid using the same connection as other tools.</p> <p>Note</p> <p>You can find out more about the dbal configuration  here.</p>"},{"location":"store/#migration","title":"Migration","text":"<p>You can also manage your schema with doctrine migrations.</p> <p>In order to be able to use <code>doctrine/migrations</code>, you have to install the associated package.</p> <pre><code>composer require doctrine/migrations\n</code></pre> <p>With this package, further commands are available such as.  for creating and executing migrations.</p> <pre><code>bin/console event-sourcing:migration:diff\nbin/console event-sourcing:migration:migrate\n</code></pre> <p>You can also change the namespace and the folder in the configuration.</p> <pre><code>patchlevel_event_sourcing:\n    migration:\n        namespace: EventSourcingMigrations\n        path: \"%kernel.project_dir%/migrations\"\n</code></pre>"},{"location":"store/#merge-orm-schema","title":"Merge ORM Schema","text":"<p>You can also merge the schema with doctrine orm. You have to set the following flag for this:</p> <pre><code>patchlevel_event_sourcing:\n    store:\n        merge_orm_schema: true\n</code></pre> <p>Note</p> <p>All schema relevant commands are removed if you activate this option. You should use the doctrine commands then.</p> <p>Warning</p> <p>If you want to merge the schema, then the same doctrine connection must be used as with the doctrine orm.  Otherwise errors may occur!</p>"},{"location":"upcasting/","title":"Upcasting","text":"<p>There are cases where the already have events in our stream but there is data missing or not in the right format for our new usecase. Normally you would need to create versioned events for this. This can lead to many versions of the same event which could lead to some chaos. To prevent this we offer <code>Upcaster</code>, which can operate on the payload before denormalizing to an event object. There you can change the event name and adjust the payload of the event.</p> <p>Info</p> <p>You can find out more about upcasting in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"upcasting/#usage","title":"Usage","text":"<pre><code>use Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcast;\nuse Patchlevel\\EventSourcing\\Serializer\\Upcast\\Upcaster;\n\nfinal class ProfileCreatedEmailLowerCastUpcaster implements Upcaster\n{\n    public function __invoke(Upcast $upcast): Upcast\n    {\n        // ignore if other event is processed\n        if ($upcast-&gt;eventName !== 'profile_created') {\n            return $upcast;\n        }\n\n        $payload = $upcast-&gt;payload;\n        $payload['email'] = strtolower($payload['email']);\n\n         return new Upcast($upcast-&gt;eventName, $payload)\n    }\n}\n</code></pre> <p>If you have the symfony default service setting with <code>autowire</code>and <code>autoconfigure</code> enabled, the upcaster is automatically recognized and registered at the <code>Upcaster</code> interface. Otherwise you have to define the upcaster in the symfony service file:</p> <pre><code>services:\n    App\\Upcaster\\ProfileCreatedEmailLowerCastUpcaster:\n      tags:\n        - event_sourcing.upcaster\n</code></pre>"},{"location":"watch_server/","title":"Watch Server","text":"<p>There is also a watch server, because you can start to see all events in real time. </p> <p>Info</p> <p>You can find out more about the watch server in the library  documentation.  This documentation is limited to bundle integration.</p>"},{"location":"watch_server/#configuration","title":"Configuration","text":"<p>To do this, you have to add the following configuration for the dev environment:</p> <pre><code>patchlevel_event_sourcing:\n    watch_server:\n        enabled: true\n</code></pre> <p>Warning</p> <p>Use this configuration for dev purposes only!</p>"},{"location":"watch_server/#watch","title":"Watch","text":"<p>There is then a new command to start the watch server:</p> <pre><code>bin/console event-sourcing:watch\n</code></pre> <p>Note</p> <p>The command can be terminated with <code>ctrl+c</code> or <code>control+c</code>.</p>"}]}