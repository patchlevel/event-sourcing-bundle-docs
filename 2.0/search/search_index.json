{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Event-Sourcing-Bundle A lightweight but also all-inclusive event sourcing bundle with a focus on developer experience and based on doctrine dbal. This bundle is a symfony integration for event-sourcing library. Features Everything is included in the package for event sourcing Based on doctrine dbal and their ecosystem Developer experience oriented and fully typed Snapshots system to quickly rebuild the aggregates Pipeline to build new projections or to migrate events Scheme management and doctrine migration support Dev tools such as a realtime event watcher Built in cli commands with symfony Installation composer require patchlevel/event-sourcing-bundle If you don't use the symfony flex recipe for this bundle, you need to follow this installation documentation . Integration Psalm","title":"Introduction"},{"location":"#event-sourcing-bundle","text":"A lightweight but also all-inclusive event sourcing bundle with a focus on developer experience and based on doctrine dbal. This bundle is a symfony integration for event-sourcing library.","title":"Event-Sourcing-Bundle"},{"location":"#features","text":"Everything is included in the package for event sourcing Based on doctrine dbal and their ecosystem Developer experience oriented and fully typed Snapshots system to quickly rebuild the aggregates Pipeline to build new projections or to migrate events Scheme management and doctrine migration support Dev tools such as a realtime event watcher Built in cli commands with symfony","title":"Features"},{"location":"#installation","text":"composer require patchlevel/event-sourcing-bundle If you don't use the symfony flex recipe for this bundle, you need to follow this installation documentation .","title":"Installation"},{"location":"#integration","text":"Psalm","title":"Integration"},{"location":"aggregate/","text":"Aggregate Info You can find out more about aggregates in the library documentation . This documentation is limited to bundle integration. Register aggregates So that the necessary service such as the repositories are available, you have to register all aggregates. You can do this in the Yaml definition by listing all aggregates with names and the associated class. patchlevel_event_sourcing : aggregates : '%kernel.project_dir%/src' Note You can also define multiple paths by specifying an array. So that the bundle knows where to look, you also have to specify a path. Here you have to give all aggregates the Aggregate attribute and give the associated name. namespace App\\Domain\\Hotel ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate(name: 'hotel')] final class Hotel extends AggregateRoot { // ... } Use snapshots You can also tell each aggregate that it should use snapshots so that the rebuilding of the state is faster. To do this, a snapshot store must first be defined. You can read that here . And then you can define the snapshot on the aggregates. patchlevel_event_sourcing : aggregates : hotel : class : App\\Domain\\Hotel\\Hotel snapshot : default If you are using attributes then you have to put the snapshot there. namespace App\\Domain\\Hotel ; use Patchlevel\\EventSourcing\\Aggregate\\SnapshotableAggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'hotel')] #[Snapshot('default')] final class Hotel extends SnapshotableAggregateRoot { // ... }","title":"Aggregate"},{"location":"aggregate/#aggregate","text":"Info You can find out more about aggregates in the library documentation . This documentation is limited to bundle integration.","title":"Aggregate"},{"location":"aggregate/#register-aggregates","text":"So that the necessary service such as the repositories are available, you have to register all aggregates. You can do this in the Yaml definition by listing all aggregates with names and the associated class. patchlevel_event_sourcing : aggregates : '%kernel.project_dir%/src' Note You can also define multiple paths by specifying an array. So that the bundle knows where to look, you also have to specify a path. Here you have to give all aggregates the Aggregate attribute and give the associated name. namespace App\\Domain\\Hotel ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; #[Aggregate(name: 'hotel')] final class Hotel extends AggregateRoot { // ... }","title":"Register aggregates"},{"location":"aggregate/#use-snapshots","text":"You can also tell each aggregate that it should use snapshots so that the rebuilding of the state is faster. To do this, a snapshot store must first be defined. You can read that here . And then you can define the snapshot on the aggregates. patchlevel_event_sourcing : aggregates : hotel : class : App\\Domain\\Hotel\\Hotel snapshot : default If you are using attributes then you have to put the snapshot there. namespace App\\Domain\\Hotel ; use Patchlevel\\EventSourcing\\Aggregate\\SnapshotableAggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'hotel')] #[Snapshot('default')] final class Hotel extends SnapshotableAggregateRoot { // ... }","title":"Use snapshots"},{"location":"cli/","text":"CLI The bundle also offers cli commands to create or delete databases . It is also possible to manage the schema and projections . Database commands There are two commands for creating and deleting a database. event-sourcing:database:create event-sourcing:database:drop Schema commands The database schema can also be created, updated and dropped. event-sourcing:schema:create event-sourcing:schema:update event-sourcing:schema:drop Note You can also register doctrine migration commands, see the store documentation for this. Projection commands The creation, deletion and rebuilding of the projections is also possible via the cli. event-sourcing:projection:create event-sourcing:projection:drop event-sourcing:projection:rebuild Note The pipeline will be used to rebuild the projection.","title":"CLI"},{"location":"cli/#cli","text":"The bundle also offers cli commands to create or delete databases . It is also possible to manage the schema and projections .","title":"CLI"},{"location":"cli/#database-commands","text":"There are two commands for creating and deleting a database. event-sourcing:database:create event-sourcing:database:drop","title":"Database commands"},{"location":"cli/#schema-commands","text":"The database schema can also be created, updated and dropped. event-sourcing:schema:create event-sourcing:schema:update event-sourcing:schema:drop Note You can also register doctrine migration commands, see the store documentation for this.","title":"Schema commands"},{"location":"cli/#projection-commands","text":"The creation, deletion and rebuilding of the projections is also possible via the cli. event-sourcing:projection:create event-sourcing:projection:drop event-sourcing:projection:rebuild Note The pipeline will be used to rebuild the projection.","title":"Projection commands"},{"location":"clock/","text":"Clock Info You can find out more about clock in the library documentation . This documentation is limited to bundle integration.","title":"Time / Clock"},{"location":"clock/#clock","text":"Info You can find out more about clock in the library documentation . This documentation is limited to bundle integration.","title":"Clock"},{"location":"event_bus/","text":"Event Bus Info You can find out more about the event bus in the library documentation . This documentation is limited to bundle integration. This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event will be dispatched to the event bus . All listeners are then called for each event. Symfony Event Bus To use the Symfony Messager , you have to define it in messenger.yaml. It's best to call the bus \"event.bus\". An event bus can have 0 or n listener for an event. So \"allow_no_handlers\" has to be configured. framework : messenger : buses : event.bus : default_middleware : allow_no_handlers We can then use this message or event bus in event sourcing: patchlevel_event_sourcing : event_bus : service : event.bus Command Bus If you use a command bus or cqrs as a pattern, then you should define a new message bus. The whole thing can look like this: framework : messenger : default_bus : command.bus buses : command.bus : ~ event.bus : default_middleware : allow_no_handlers Warning You should deactivate the autoconfigure feature for the handlers, otherwise they will be registered in both handlers.","title":"Event Bus"},{"location":"event_bus/#event-bus","text":"Info You can find out more about the event bus in the library documentation . This documentation is limited to bundle integration. This library uses the core principle called event bus . For all events that are persisted (when the save method has been executed on the repository ), the event will be dispatched to the event bus . All listeners are then called for each event.","title":"Event Bus"},{"location":"event_bus/#symfony-event-bus","text":"To use the Symfony Messager , you have to define it in messenger.yaml. It's best to call the bus \"event.bus\". An event bus can have 0 or n listener for an event. So \"allow_no_handlers\" has to be configured. framework : messenger : buses : event.bus : default_middleware : allow_no_handlers We can then use this message or event bus in event sourcing: patchlevel_event_sourcing : event_bus : service : event.bus","title":"Symfony Event Bus"},{"location":"event_bus/#command-bus","text":"If you use a command bus or cqrs as a pattern, then you should define a new message bus. The whole thing can look like this: framework : messenger : default_bus : command.bus buses : command.bus : ~ event.bus : default_middleware : allow_no_handlers Warning You should deactivate the autoconfigure feature for the handlers, otherwise they will be registered in both handlers.","title":"Command Bus"},{"location":"events/","text":"Events Info You can find out more about events in the library documentation . This documentation is limited to bundle integration.","title":"Events"},{"location":"events/#events","text":"Info You can find out more about events in the library documentation . This documentation is limited to bundle integration.","title":"Events"},{"location":"getting_started/","text":"Getting Started In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out. For this example we use following packages: symfony/uid symfony/mailer Define some events First we define the events that happen in our system. A hotel can be created with a name : namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer ; use Symfony\\Component\\Uid\\Uuid ; #[Event('hotel.created')] final class HotelCreated { public function __construct ( #[Normalize(new UuidNormalizer())] public readonly Uuid $id , public readonly string $hotelName ) { } } A guest can check in by name: namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('hotel.guest_is_checked_in')] final class GuestIsCheckedIn { public function __construct ( public readonly string $guestName ) { } } And also check out again: namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('hotel.guest_is_checked_out')] final class GuestIsCheckedOut { public function __construct ( public readonly string $guestName ) { } } Define aggregates Next we need to define the aggregate. So the hotel and how the hotel should behave. We have also defined the create , checkIn and checkOut methods accordingly. These events are thrown here and the state of the hotel is also changed. namespace App\\Domain\\Hotel ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Symfony\\Component\\Uid\\Uuid ; #[Aggregate(name: 'hotel')] final class Hotel extends AggregateRoot { private Uuid $id ; private string $name ; /** * @var list<string> */ private array $guests ; public function name () : string { return $this -> name ; } public function guests () : int { return $this -> guests ; } public static function create ( Uuid $id , string $hotelName ) : self { $self = new self (); $self -> recordThat ( new HotelCreated ( $id , $hotelName )); return $self ; } public function checkIn ( string $guestName ) : void { if ( in_array ( $guestName , $this -> guests , true )) { throw new GuestHasAlreadyCheckedIn ( $guestName ); } $this -> recordThat ( new GuestIsCheckedIn ( guestName )); } public function checkOut ( string $guestName ) : void { if ( ! in_array ( $guestName , $this -> guests , true )) { throw new IsNotAGuest ( $guestName ); } $this -> recordThat ( new GuestIsCheckedOut ( $guestName )); } #[Apply] protected function applyHotelCreated ( HotelCreated $event ) : void { $this -> id = $event -> id ; $this -> name = $event -> hotelName ; $this -> guests = []; } #[Apply] protected function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> guests [] = $event -> guestName ; } #[Apply] protected function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> guests = array_values ( array_filter ( $this -> guests , fn ( $name ) => $name !== $event -> guestName ; ) ); } public function aggregateRootId () : string { return $this -> id -> toString (); } } Note You can find out more about aggregates here . Define projections So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. namespace App\\Projection ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class HotelProjection implements Projection { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } #[Handle(HotelCreated::class)] public function handleHotelCreated ( Message $message ) : void { $this -> db -> insert ( 'hotel' , [ 'id' => $message -> aggregateId (), 'name' => $message -> event () -> hotelName (), 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } Warning autoconfigure need to be enabled, otherwise you need add the event_sourcing.projection tag. Note You can find out more about projections here . Processor In our example we also want to send an email to the head office as soon as a guest is checked in. namespace App\\Domain\\Hotel\\Listener ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Symfony\\Component\\Mailer\\MailerInterface ; use Symfony\\Component\\Mime\\Email ; final class SendCheckInEmailListener implements Listener { private MailerInterface $mailer ; private function __construct ( MailerInterface $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $email = ( new Email ()) -> from ( 'noreply@patchlevel.de' ) -> to ( 'hq@patchlevel.de' ) -> subject ( 'Guest is checked in' ) -> text ( sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ())); $this -> mailer -> send ( $email ); } } Warning autoconfigure need to be enabled, otherwise you need add the event_sourcing.processor tag. Note You can find out more about processor here . Database setup So that we can actually write the data to a database, we need the associated schema and databases. bin/console event-sourcing:database:create bin/console event-sourcing:schema:create bin/console event-sourcing:projection:create Usage We are now ready to use the Event Sourcing System. We can load, change and save aggregates. namespace App\\Controller ; use App\\Domain\\Hotel\\Hotel ; use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; use Symfony\\Component\\HttpFoundation\\JsonResponse ; use Symfony\\Component\\HttpFoundation\\Request ; use Symfony\\Component\\Routing\\Annotation\\Route ; use Symfony\\Component\\Uid\\Uuid ; final class HotelController { /** @var Repository<Hotel> */ private Repository $hotelRepository ; public function __construct ( RepositoryManager $repositoryManager ) { $this -> hotelRepository = $repositoryManager -> get ( Hotel :: class ); } #[Route(\"/create\", methods:[\"POST\"])] public function createAction ( Request $request ) : JsonResponse { $name = $request -> request -> get ( 'name' ); // need validation! $id = Uuid :: v4 (); $hotel = Hotel :: create ( $id , $name ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse ([ 'id' => $id -> toString ()]); } #[Route(\"/:id/check-in\", methods:[\"POST\"])] public function createAction ( string $id , Request $request ) : JsonResponse { $id = Uuid :: fromString ( $id ); $guestName = $request -> request -> get ( 'name' ); // need validation! $hotel = $this -> hotelRepository -> load ( $id ); $hotel -> checkIn ( $guestName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse ([ 'id' => $id -> toString ()]); } #[Route(\"/:id/check-out\", methods:[\"POST\"])] public function createAction ( string $id , Request $request ) : JsonResponse { $id = Uuid :: fromString ( $id ); $guestName = $request -> request -> get ( 'name' ); // need validation! $hotel = $this -> hotelRepository -> load ( $id ); $hotel -> checkOut ( $guestName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse ([ 'id' => $id -> toString ()]); } } Note You can also use a command bus .","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"In our little getting started example, we manage hotels. We keep the example small, so we can only create hotels and let guests check in and check out. For this example we use following packages: symfony/uid symfony/mailer","title":"Getting Started"},{"location":"getting_started/#define-some-events","text":"First we define the events that happen in our system. A hotel can be created with a name : namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Normalize ; use Patchlevel\\EventSourcingBundle\\Normalizer\\UuidNormalizer ; use Symfony\\Component\\Uid\\Uuid ; #[Event('hotel.created')] final class HotelCreated { public function __construct ( #[Normalize(new UuidNormalizer())] public readonly Uuid $id , public readonly string $hotelName ) { } } A guest can check in by name: namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('hotel.guest_is_checked_in')] final class GuestIsCheckedIn { public function __construct ( public readonly string $guestName ) { } } And also check out again: namespace App\\Domain\\Hotel\\Event ; use Patchlevel\\EventSourcing\\Attribute\\Event ; #[Event('hotel.guest_is_checked_out')] final class GuestIsCheckedOut { public function __construct ( public readonly string $guestName ) { } }","title":"Define some events"},{"location":"getting_started/#define-aggregates","text":"Next we need to define the aggregate. So the hotel and how the hotel should behave. We have also defined the create , checkIn and checkOut methods accordingly. These events are thrown here and the state of the hotel is also changed. namespace App\\Domain\\Hotel ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Apply ; use Symfony\\Component\\Uid\\Uuid ; #[Aggregate(name: 'hotel')] final class Hotel extends AggregateRoot { private Uuid $id ; private string $name ; /** * @var list<string> */ private array $guests ; public function name () : string { return $this -> name ; } public function guests () : int { return $this -> guests ; } public static function create ( Uuid $id , string $hotelName ) : self { $self = new self (); $self -> recordThat ( new HotelCreated ( $id , $hotelName )); return $self ; } public function checkIn ( string $guestName ) : void { if ( in_array ( $guestName , $this -> guests , true )) { throw new GuestHasAlreadyCheckedIn ( $guestName ); } $this -> recordThat ( new GuestIsCheckedIn ( guestName )); } public function checkOut ( string $guestName ) : void { if ( ! in_array ( $guestName , $this -> guests , true )) { throw new IsNotAGuest ( $guestName ); } $this -> recordThat ( new GuestIsCheckedOut ( $guestName )); } #[Apply] protected function applyHotelCreated ( HotelCreated $event ) : void { $this -> id = $event -> id ; $this -> name = $event -> hotelName ; $this -> guests = []; } #[Apply] protected function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> guests [] = $event -> guestName ; } #[Apply] protected function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> guests = array_values ( array_filter ( $this -> guests , fn ( $name ) => $name !== $event -> guestName ; ) ); } public function aggregateRootId () : string { return $this -> id -> toString (); } } Note You can find out more about aggregates here .","title":"Define aggregates"},{"location":"getting_started/#define-projections","text":"So that we can see all the hotels on our website and also see how many guests are currently visiting the hotels, we need a projection for it. namespace App\\Projection ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Attribute\\Create ; use Patchlevel\\EventSourcing\\Attribute\\Drop ; use Patchlevel\\EventSourcing\\Attribute\\Handle ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class HotelProjection implements Projection { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } #[Handle(HotelCreated::class)] public function handleHotelCreated ( Message $message ) : void { $this -> db -> insert ( 'hotel' , [ 'id' => $message -> aggregateId (), 'name' => $message -> event () -> hotelName (), 'guests' => 0 ] ); } #[Handle(GuestIsCheckedIn::class)] public function handleGuestIsCheckedIn ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Handle(GuestIsCheckedOut::class)] public function handleGuestIsCheckedOut ( Message $message ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $message -> aggregateId ()] ); } #[Create] public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } #[Drop] public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } Warning autoconfigure need to be enabled, otherwise you need add the event_sourcing.projection tag. Note You can find out more about projections here .","title":"Define projections"},{"location":"getting_started/#processor","text":"In our example we also want to send an email to the head office as soon as a guest is checked in. namespace App\\Domain\\Hotel\\Listener ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Patchlevel\\EventSourcing\\EventBus\\Message ; use Symfony\\Component\\Mailer\\MailerInterface ; use Symfony\\Component\\Mime\\Email ; final class SendCheckInEmailListener implements Listener { private MailerInterface $mailer ; private function __construct ( MailerInterface $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( Message $message ) : void { $event = $message -> event (); if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $email = ( new Email ()) -> from ( 'noreply@patchlevel.de' ) -> to ( 'hq@patchlevel.de' ) -> subject ( 'Guest is checked in' ) -> text ( sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ())); $this -> mailer -> send ( $email ); } } Warning autoconfigure need to be enabled, otherwise you need add the event_sourcing.processor tag. Note You can find out more about processor here .","title":"Processor"},{"location":"getting_started/#database-setup","text":"So that we can actually write the data to a database, we need the associated schema and databases. bin/console event-sourcing:database:create bin/console event-sourcing:schema:create bin/console event-sourcing:projection:create","title":"Database setup"},{"location":"getting_started/#usage","text":"We are now ready to use the Event Sourcing System. We can load, change and save aggregates. namespace App\\Controller ; use App\\Domain\\Hotel\\Hotel ; use Patchlevel\\EventSourcing\\Repository\\Repository ; use Patchlevel\\EventSourcing\\Repository\\RepositoryManager ; use Symfony\\Component\\HttpFoundation\\JsonResponse ; use Symfony\\Component\\HttpFoundation\\Request ; use Symfony\\Component\\Routing\\Annotation\\Route ; use Symfony\\Component\\Uid\\Uuid ; final class HotelController { /** @var Repository<Hotel> */ private Repository $hotelRepository ; public function __construct ( RepositoryManager $repositoryManager ) { $this -> hotelRepository = $repositoryManager -> get ( Hotel :: class ); } #[Route(\"/create\", methods:[\"POST\"])] public function createAction ( Request $request ) : JsonResponse { $name = $request -> request -> get ( 'name' ); // need validation! $id = Uuid :: v4 (); $hotel = Hotel :: create ( $id , $name ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse ([ 'id' => $id -> toString ()]); } #[Route(\"/:id/check-in\", methods:[\"POST\"])] public function createAction ( string $id , Request $request ) : JsonResponse { $id = Uuid :: fromString ( $id ); $guestName = $request -> request -> get ( 'name' ); // need validation! $hotel = $this -> hotelRepository -> load ( $id ); $hotel -> checkIn ( $guestName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse ([ 'id' => $id -> toString ()]); } #[Route(\"/:id/check-out\", methods:[\"POST\"])] public function createAction ( string $id , Request $request ) : JsonResponse { $id = Uuid :: fromString ( $id ); $guestName = $request -> request -> get ( 'name' ); // need validation! $hotel = $this -> hotelRepository -> load ( $id ); $hotel -> checkOut ( $guestName ); $this -> hotelRepository -> save ( $hotel ); return new JsonResponse ([ 'id' => $id -> toString ()]); } } Note You can also use a command bus .","title":"Usage"},{"location":"installation/","text":"Installation If you are not using a symfony flex or the recipes for it, then you have to carry out a few installation steps by hand. Require package The first thing to do is to install packet if it has not already been done. composer require patchlevel/event-sourcing-bundle Note how to install composer Enable bundle Then we have to activate the bundle in the config/bundles.php : return [ Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle :: class => [ 'all' => true ], ]; If you don't have config/bundles.php then you need to add the bundle in the kernel: class AppKernel extends Kernel { public function registerBundles () { $bundles = [ new Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle (), ]; } } Configuration file Now you have to add a minimal configuration file here config/packages/patchlevel_event_sourcing.yaml . patchlevel_event_sourcing : aggregates : '%kernel.project_dir%/src' events : '%kernel.project_dir%/src' connection : url : '%env(EVENTSTORE_URL)%' Dotenv Finally we have to fill the ENV variable with a connection url. EVENTSTORE_URL=mysql://user:secret@localhost/app Note You can find out more about what a connection url looks like here . Now you can go back to getting started .","title":"Installation"},{"location":"installation/#installation","text":"If you are not using a symfony flex or the recipes for it, then you have to carry out a few installation steps by hand.","title":"Installation"},{"location":"installation/#require-package","text":"The first thing to do is to install packet if it has not already been done. composer require patchlevel/event-sourcing-bundle Note how to install composer","title":"Require package"},{"location":"installation/#enable-bundle","text":"Then we have to activate the bundle in the config/bundles.php : return [ Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle :: class => [ 'all' => true ], ]; If you don't have config/bundles.php then you need to add the bundle in the kernel: class AppKernel extends Kernel { public function registerBundles () { $bundles = [ new Patchlevel\\EventSourcingBundle\\PatchlevelEventSourcingBundle (), ]; } }","title":"Enable bundle"},{"location":"installation/#configuration-file","text":"Now you have to add a minimal configuration file here config/packages/patchlevel_event_sourcing.yaml . patchlevel_event_sourcing : aggregates : '%kernel.project_dir%/src' events : '%kernel.project_dir%/src' connection : url : '%env(EVENTSTORE_URL)%'","title":"Configuration file"},{"location":"installation/#dotenv","text":"Finally we have to fill the ENV variable with a connection url. EVENTSTORE_URL=mysql://user:secret@localhost/app Note You can find out more about what a connection url looks like here . Now you can go back to getting started .","title":"Dotenv"},{"location":"message_decorator/","text":"Message Decorator Info You can find out more about message decorator in the library documentation . This documentation is limited to bundle integration.","title":"Message Decorator"},{"location":"message_decorator/#message-decorator","text":"Info You can find out more about message decorator in the library documentation . This documentation is limited to bundle integration.","title":"Message Decorator"},{"location":"migration/","text":"Migration Info You can find out more about migration in the library documentation . This documentation is limited to bundle integration.","title":"Schema Migration"},{"location":"migration/#migration","text":"Info You can find out more about migration in the library documentation . This documentation is limited to bundle integration.","title":"Migration"},{"location":"normalizer/","text":"Normalizer Info You can find out more about normalizer in the library documentation . This documentation is limited to bundle integration.","title":"Normalizer"},{"location":"normalizer/#normalizer","text":"Info You can find out more about normalizer in the library documentation . This documentation is limited to bundle integration.","title":"Normalizer"},{"location":"pipeline/","text":"Pipeline Info You can find out more about pipeline in the library documentation . This documentation is limited to bundle integration. A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : namespace App\\Command ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; use Patchlevel\\EventSourcing\\Serializer\\Serializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; use Patchlevel\\EventSourcing\\Store\\Store ; use Symfony\\Component\\Console\\Command\\Command ; use Symfony\\Component\\Console\\Input\\InputInterface ; use Symfony\\Component\\Console\\Output\\OutputInterface ; use Symfony\\Component\\Console\\Style\\SymfonyStyle ; class CreateUserCommand extends Command { protected static $defaultName = 'app:event-sourcing:migrate-db-v2' ; private Store $oldStore ; private Connection $newConnection ; private Serializer $serializer ; private AggregateRootRegistry $aggregateRegistry ; public function __construct ( Store $oldStore , Connection $newConnection , Serializer $serializer , AggregateRootRegistry $aggregateRegistry ) { $this -> oldStore = $oldStore ; $this -> newConnection = $newConnection ; $this -> serializer = $serializer ; $this -> aggregateRegistry = $aggregateRegistry ; parent :: __construct (); } protected function configure () : void { } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $console = new SymfonyStyle ( $input , $output ); $newStore = new MultiTableStore ( $this -> newConnection , $this -> serializer , $this -> aggregateRegistry ); $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return NewVisited :: raise ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); $console -> progressStart ( $pipeline -> count ()); $pipeline -> run ( static function () use ( $console ) : void { $console -> progressAdvance (); }); $console -> progressFinish (); $console -> success ( 'finish' ); return Command :: SUCCESS ; } } The whole thing just has to be plugged together. services : App\\Command\\CreateUserCommand : arguments : newConnection : '@doctrine.dbal.new_connection' Note If you have the doctrine bundle for the dbal connections, then you can autowire it.","title":"Pipeline"},{"location":"pipeline/#pipeline","text":"Info You can find out more about pipeline in the library documentation . This documentation is limited to bundle integration. A store is immutable, i.e. it cannot be changed afterwards. This includes both manipulating events and deleting them. Instead, you can duplicate the store and manipulate the events in the process. Thus the old store remains untouched and you can test the new store beforehand, whether the migration worked. In this example the event PrivacyAdded is removed and the event OldVisited is replaced by NewVisited : namespace App\\Command ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Metadata\\AggregateRoot\\AggregateRootRegistry ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ExcludeEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\RecalculatePlayheadMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Middleware\\ReplaceEventMiddleware ; use Patchlevel\\EventSourcing\\Pipeline\\Pipeline ; use Patchlevel\\EventSourcing\\Pipeline\\Source\\StoreSource ; use Patchlevel\\EventSourcing\\Pipeline\\Target\\StoreTarget ; use Patchlevel\\EventSourcing\\Serializer\\Serializer ; use Patchlevel\\EventSourcing\\Store\\MultiTableStore ; use Patchlevel\\EventSourcing\\Store\\Store ; use Symfony\\Component\\Console\\Command\\Command ; use Symfony\\Component\\Console\\Input\\InputInterface ; use Symfony\\Component\\Console\\Output\\OutputInterface ; use Symfony\\Component\\Console\\Style\\SymfonyStyle ; class CreateUserCommand extends Command { protected static $defaultName = 'app:event-sourcing:migrate-db-v2' ; private Store $oldStore ; private Connection $newConnection ; private Serializer $serializer ; private AggregateRootRegistry $aggregateRegistry ; public function __construct ( Store $oldStore , Connection $newConnection , Serializer $serializer , AggregateRootRegistry $aggregateRegistry ) { $this -> oldStore = $oldStore ; $this -> newConnection = $newConnection ; $this -> serializer = $serializer ; $this -> aggregateRegistry = $aggregateRegistry ; parent :: __construct (); } protected function configure () : void { } protected function execute ( InputInterface $input , OutputInterface $output ) : int { $console = new SymfonyStyle ( $input , $output ); $newStore = new MultiTableStore ( $this -> newConnection , $this -> serializer , $this -> aggregateRegistry ); $pipeline = new Pipeline ( new StoreSource ( $oldStore ), new StoreTarget ( $newStore ), [ new ExcludeEventMiddleware ([ PrivacyAdded :: class ]), new ReplaceEventMiddleware ( OldVisited :: class , static function ( OldVisited $oldVisited ) { return NewVisited :: raise ( $oldVisited -> profileId ()); }), new RecalculatePlayheadMiddleware (), ] ); $console -> progressStart ( $pipeline -> count ()); $pipeline -> run ( static function () use ( $console ) : void { $console -> progressAdvance (); }); $console -> progressFinish (); $console -> success ( 'finish' ); return Command :: SUCCESS ; } } The whole thing just has to be plugged together. services : App\\Command\\CreateUserCommand : arguments : newConnection : '@doctrine.dbal.new_connection' Note If you have the doctrine bundle for the dbal connections, then you can autowire it.","title":"Pipeline"},{"location":"processor/","text":"Processor Info You can find out more about processor in the library documentation . This documentation is limited to bundle integration. The processor is a kind of event bus listener that can execute actions on certain events. A process can be for example used to send an email when a guest is checked in: namespace App\\Domain\\Hotel\\Listener ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Symfony\\Component\\Mailer\\MailerInterface ; use Symfony\\Component\\Mime\\Email ; final class SendCheckInEmailListener implements Listener { private MailerInterface $mailer ; private function __construct ( MailerInterface $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( AggregateChanged $event ) : void { if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $email = ( new Email ()) -> from ( 'noreply@patchlevel.de' ) -> to ( 'hq@patchlevel.de' ) -> subject ( 'Guest is checked in' ) -> text ( sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ())); $this -> mailer -> send ( $email ); } } If you have the symfony default service setting with autowire and autoconfiger enabled, the processor is automatically recognized and registered at the Listener interface. Otherwise you have to define the processor in the symfony service file: services : App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener : tags : - event_sourcing.processor Priority (since v1.2) You can also determine the priority in which the processors are executed. The higher the priority, the earlier the processor is executed. You have to add the tag manually and specify the priority. services : App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener : autoconfigure : false tags : - name : event_sourcing.processor priority : 16 Warning You have to deactivate the autoconfigure for this service, otherwise the service will be added twice. Note The projection listener has a priority of -32 , to do things after the projection, you have to be lower.","title":"Processor"},{"location":"processor/#processor","text":"Info You can find out more about processor in the library documentation . This documentation is limited to bundle integration. The processor is a kind of event bus listener that can execute actions on certain events. A process can be for example used to send an email when a guest is checked in: namespace App\\Domain\\Hotel\\Listener ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateChanged ; use Patchlevel\\EventSourcing\\EventBus\\Listener ; use Symfony\\Component\\Mailer\\MailerInterface ; use Symfony\\Component\\Mime\\Email ; final class SendCheckInEmailListener implements Listener { private MailerInterface $mailer ; private function __construct ( MailerInterface $mailer ) { $this -> mailer = $mailer ; } public function __invoke ( AggregateChanged $event ) : void { if ( ! $event instanceof GuestIsCheckedIn ) { return ; } $email = ( new Email ()) -> from ( 'noreply@patchlevel.de' ) -> to ( 'hq@patchlevel.de' ) -> subject ( 'Guest is checked in' ) -> text ( sprintf ( 'A new guest named \"%s\" is checked in' , $event -> guestName ())); $this -> mailer -> send ( $email ); } } If you have the symfony default service setting with autowire and autoconfiger enabled, the processor is automatically recognized and registered at the Listener interface. Otherwise you have to define the processor in the symfony service file: services : App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener : tags : - event_sourcing.processor","title":"Processor"},{"location":"processor/#priority-since-v12","text":"You can also determine the priority in which the processors are executed. The higher the priority, the earlier the processor is executed. You have to add the tag manually and specify the priority. services : App\\Domain\\Hotel\\Listener\\SendCheckInEmailListener : autoconfigure : false tags : - name : event_sourcing.processor priority : 16 Warning You have to deactivate the autoconfigure for this service, otherwise the service will be added twice. Note The projection listener has a priority of -32 , to do things after the projection, you have to be lower.","title":"Priority (since v1.2)"},{"location":"projection/","text":"Projection Info You can find out more about projection in the library documentation . This documentation is limited to bundle integration. With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch. Define Projection In this example we are simply mapping hotel statistics: namespace App\\Projection ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class HotelProjection implements Projection { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } public static function getHandledMessages () : iterable { yield HotelCreated :: class => 'applyHotelCreated' ; yield GuestIsCheckedIn :: class => 'applyGuestIsCheckedIn' ; yield GuestIsCheckedOut :: class => 'applyGuestIsCheckedOut' ; } public function applyHotelCreated ( HotelCreated $event ) : void { $this -> db -> insert ( 'hotel' , [ 'id' => $event -> aggregateId (), 'name' => $event -> hotelName (), 'guests' => 0 ] ); } public function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $event -> aggregateId ()] ); } public function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $event -> aggregateId ()] ); } public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } If you have the symfony default service setting with autowire and autoconfigure enabled, the projection is automatically recognized and registered at the Projection interface. Otherwise you have to define the projection in the symfony service file: services : App\\Projection\\HotelProjection : tags : - event_sourcing.projection Projection commands The bundle also provides a few commands to create, delete or rebuild projections: bin/console event-sourcing:projection:create bin/console event-sourcing:projection:drop bin/console event-sourcing:projection:rebuild","title":"Projection"},{"location":"projection/#projection","text":"Info You can find out more about projection in the library documentation . This documentation is limited to bundle integration. With projections you can create your data optimized for reading. projections can be adjusted, deleted or rebuilt at any time. This is possible because the source of truth remains untouched and everything can always be reproduced from the events. The target of a projection can be anything. Either a file, a relational database, a no-sql database like mongodb or an elasticsearch.","title":"Projection"},{"location":"projection/#define-projection","text":"In this example we are simply mapping hotel statistics: namespace App\\Projection ; use App\\Domain\\Hotel\\Event\\HotelCreated ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedIn ; use App\\Domain\\Hotel\\Event\\GuestIsCheckedOut ; use Doctrine\\DBAL\\Connection ; use Patchlevel\\EventSourcing\\Projection\\Projection ; final class HotelProjection implements Projection { private Connection $db ; public function __construct ( Connection $db ) { $this -> db = $db ; } public static function getHandledMessages () : iterable { yield HotelCreated :: class => 'applyHotelCreated' ; yield GuestIsCheckedIn :: class => 'applyGuestIsCheckedIn' ; yield GuestIsCheckedOut :: class => 'applyGuestIsCheckedOut' ; } public function applyHotelCreated ( HotelCreated $event ) : void { $this -> db -> insert ( 'hotel' , [ 'id' => $event -> aggregateId (), 'name' => $event -> hotelName (), 'guests' => 0 ] ); } public function applyGuestIsCheckedIn ( GuestIsCheckedIn $event ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests + 1 WHERE id = ?;' , [ $event -> aggregateId ()] ); } public function applyGuestIsCheckedOut ( GuestIsCheckedOut $event ) : void { $this -> db -> executeStatement ( 'UPDATE hotel SET guests = guests - 1 WHERE id = ?;' , [ $event -> aggregateId ()] ); } public function create () : void { $this -> db -> executeStatement ( 'CREATE TABLE IF NOT EXISTS hotel (id VARCHAR PRIMARY KEY, name VARCHAR, guests INTEGER);' ); } public function drop () : void { $this -> db -> executeStatement ( 'DROP TABLE IF EXISTS hotel;' ); } } If you have the symfony default service setting with autowire and autoconfigure enabled, the projection is automatically recognized and registered at the Projection interface. Otherwise you have to define the projection in the symfony service file: services : App\\Projection\\HotelProjection : tags : - event_sourcing.projection","title":"Define Projection"},{"location":"projection/#projection-commands","text":"The bundle also provides a few commands to create, delete or rebuild projections: bin/console event-sourcing:projection:create bin/console event-sourcing:projection:drop bin/console event-sourcing:projection:rebuild","title":"Projection commands"},{"location":"repository/","text":"Repository Info You can find out more about repository in the library documentation . This documentation is limited to bundle integration. A repository takes care of storing and loading the aggregates . The design pattern of the same name is also used. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate. Use repositories Every aggregate that has been defined and registered automatically has a repository. These repositories can also be auto-updated. To do this, you have to use the Typehint repository and structure the variable as follows. Aggregate name with a Repository suffix. For example we have the aggregate hotel , then you can build the typhint as follows: Patchlevel\\EventSourcing\\Repository\\Repository $hotelRepository . use Patchlevel\\EventSourcing\\Repository\\Repository ; final class HotelController { private Repository $hotelRepository ; public function __construct ( Repository $hotelRepository ) { $this -> hotelRepository = $hotelRepository ; } // ... } Note You can find out more about autowire here","title":"Repository"},{"location":"repository/#repository","text":"Info You can find out more about repository in the library documentation . This documentation is limited to bundle integration. A repository takes care of storing and loading the aggregates . The design pattern of the same name is also used. Every aggregate needs a repository to be stored. And each repository is only responsible for one aggregate.","title":"Repository"},{"location":"repository/#use-repositories","text":"Every aggregate that has been defined and registered automatically has a repository. These repositories can also be auto-updated. To do this, you have to use the Typehint repository and structure the variable as follows. Aggregate name with a Repository suffix. For example we have the aggregate hotel , then you can build the typhint as follows: Patchlevel\\EventSourcing\\Repository\\Repository $hotelRepository . use Patchlevel\\EventSourcing\\Repository\\Repository ; final class HotelController { private Repository $hotelRepository ; public function __construct ( Repository $hotelRepository ) { $this -> hotelRepository = $hotelRepository ; } // ... } Note You can find out more about autowire here","title":"Use repositories"},{"location":"snapshots/","text":"Snapshots Info You can find out more about snapshots in the library documentation . This documentation is limited to bundle integration. Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all. Using Symfony Cache You can use symfony cache to define the target of the snapshot store. framework : cache : default_redis_provider : 'redis://localhost' pools : event_sourcing.cache : adapter : cache.adapter.redis After this, you need define the snapshot store. Symfony cache implement the psr6 interface, so we need choose this type and enter the id from the cache service. patchlevel_event_sourcing : snapshot_stores : default : service : event_sourcing.cache Finally, you have to tell the aggregate that it should use this snapshot store. namespace App\\Domain\\Profile ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'profile')] #[Snapshot('default')] final class Profile extends AggregateRoot { // ... } Book You can find out more about the attributes here . Batch So that not every write process also writes to the cache at the same time, you can also say from how many events should be written to the snapshot store first. This minimizes the write operations to the cache, which improves performance. namespace App\\Domain\\Profile ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'profile')] #[Snapshot('default', batch: 1000)] final class Profile extends AggregateRoot { // ... }","title":"Snapshots"},{"location":"snapshots/#snapshots","text":"Info You can find out more about snapshots in the library documentation . This documentation is limited to bundle integration. Some aggregates can have a large number of events. This is not a problem if there are a few hundred. But if the number gets bigger at some point, then loading and rebuilding can become slow. The snapshot system can be used to control this. Normally, the events are all executed again on the aggregate in order to rebuild the current state. With a snapshot , we can shorten the way in which we temporarily save the current state of the aggregate. When loading it is checked whether the snapshot exists. If a hit exists, the aggregate is built up with the help of the snapshot. A check is then made to see whether further events have existed since the snapshot and these are then also executed on the aggregate. Here, however, only the last events are loaded from the database and not all.","title":"Snapshots"},{"location":"snapshots/#using-symfony-cache","text":"You can use symfony cache to define the target of the snapshot store. framework : cache : default_redis_provider : 'redis://localhost' pools : event_sourcing.cache : adapter : cache.adapter.redis After this, you need define the snapshot store. Symfony cache implement the psr6 interface, so we need choose this type and enter the id from the cache service. patchlevel_event_sourcing : snapshot_stores : default : service : event_sourcing.cache Finally, you have to tell the aggregate that it should use this snapshot store. namespace App\\Domain\\Profile ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'profile')] #[Snapshot('default')] final class Profile extends AggregateRoot { // ... } Book You can find out more about the attributes here .","title":"Using Symfony Cache"},{"location":"snapshots/#batch","text":"So that not every write process also writes to the cache at the same time, you can also say from how many events should be written to the snapshot store first. This minimizes the write operations to the cache, which improves performance. namespace App\\Domain\\Profile ; use Patchlevel\\EventSourcing\\Aggregate\\AggregateRoot ; use Patchlevel\\EventSourcing\\Attribute\\Aggregate ; use Patchlevel\\EventSourcing\\Attribute\\Snapshot ; #[Aggregate(name: 'profile')] #[Snapshot('default', batch: 1000)] final class Profile extends AggregateRoot { // ... }","title":"Batch"},{"location":"store/","text":"Store Info You can find out more about stores in the library documentation . This documentation is limited to bundle integration. In the end, the events have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies. Store types We offer two store strategies that you can choose as you like. Single Table Store With the single_table everything is saved in one table. patchlevel_event_sourcing : store : type : single_table Note You can switch between strategies using the pipeline . Multi Table Store With the multi_table a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. patchlevel_event_sourcing : store : type : multi_table Note You can switch between strategies using the pipeline . Manage database and schema The bundle provides you with a few commands with which you can create and delete the database . You can also use it to create, edit and delete the schema . Create and drop database bin/console event-sourcing:database:create bin/console event-sourcing:database:drop Create, update and drop schema bin/console event-sourcing:schema:create bin/console event-sourcing:schema:udapte bin/console event-sourcing:schema:drop Use doctrine connection If you have installed the doctrine bundle , you can also define the connection via doctrine and then use it in the store. doctrine : dbal : connections : eventstore : url : '%env(EVENTSTORE_URL)%' patchlevel_event_sourcing : connection : service : doctrine.dbal.eventstore_connection Warning You should avoid that this connection or database is used by other tools or libraries. Create for e.g. doctrine orm its own database and connection. Note You can find out more about the dbal configuration here . Migration You can also manage your schema with doctrine migrations. In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations With this package, further commands are available such as. for creating and executing migrations. bin/console event-sourcing:migration:diff bin/console event-sourcing:migration:migrate You can also change the namespace and the folder in the configuration. patchlevel_event_sourcing : migration : namespace : EventSourcingMigrations path : \"%kernel.project_dir%/migrations\"","title":"Store"},{"location":"store/#store","text":"Info You can find out more about stores in the library documentation . This documentation is limited to bundle integration. In the end, the events have to be saved somewhere. The library is based on doctrine dbal and offers two different store strategies.","title":"Store"},{"location":"store/#store-types","text":"We offer two store strategies that you can choose as you like.","title":"Store types"},{"location":"store/#single-table-store","text":"With the single_table everything is saved in one table. patchlevel_event_sourcing : store : type : single_table Note You can switch between strategies using the pipeline .","title":"Single Table Store"},{"location":"store/#multi-table-store","text":"With the multi_table a separate table is created for each aggregate type. In addition, a meta table is created by referencing all events in the correct order. patchlevel_event_sourcing : store : type : multi_table Note You can switch between strategies using the pipeline .","title":"Multi Table Store"},{"location":"store/#manage-database-and-schema","text":"The bundle provides you with a few commands with which you can create and delete the database . You can also use it to create, edit and delete the schema .","title":"Manage database and schema"},{"location":"store/#create-and-drop-database","text":"bin/console event-sourcing:database:create bin/console event-sourcing:database:drop","title":"Create and drop database"},{"location":"store/#create-update-and-drop-schema","text":"bin/console event-sourcing:schema:create bin/console event-sourcing:schema:udapte bin/console event-sourcing:schema:drop","title":"Create, update and drop schema"},{"location":"store/#use-doctrine-connection","text":"If you have installed the doctrine bundle , you can also define the connection via doctrine and then use it in the store. doctrine : dbal : connections : eventstore : url : '%env(EVENTSTORE_URL)%' patchlevel_event_sourcing : connection : service : doctrine.dbal.eventstore_connection Warning You should avoid that this connection or database is used by other tools or libraries. Create for e.g. doctrine orm its own database and connection. Note You can find out more about the dbal configuration here .","title":"Use doctrine connection"},{"location":"store/#migration","text":"You can also manage your schema with doctrine migrations. In order to be able to use doctrine/migrations , you have to install the associated package. composer require doctrine/migrations With this package, further commands are available such as. for creating and executing migrations. bin/console event-sourcing:migration:diff bin/console event-sourcing:migration:migrate You can also change the namespace and the folder in the configuration. patchlevel_event_sourcing : migration : namespace : EventSourcingMigrations path : \"%kernel.project_dir%/migrations\"","title":"Migration"},{"location":"upcasting/","text":"Upcasting Info You can find out more about upcasting in the library documentation . This documentation is limited to bundle integration.","title":"Upcasting"},{"location":"upcasting/#upcasting","text":"Info You can find out more about upcasting in the library documentation . This documentation is limited to bundle integration.","title":"Upcasting"},{"location":"watch_server/","text":"Watch Server Info You can find out more about the watch server in the library documentation . This documentation is limited to bundle integration. There is also a watch server, because you can start to see all events in real time. To do this, you have to add the following configuration for the dev environment: patchlevel_event_sourcing : watch_server : enabled : true Warning Use this configuration for dev purposes only! There is then a new command to start the watch server: bin/console event-sourcing:watch Note The command can be terminated with ctrl+c or control+c .","title":"Watch Server"},{"location":"watch_server/#watch-server","text":"Info You can find out more about the watch server in the library documentation . This documentation is limited to bundle integration. There is also a watch server, because you can start to see all events in real time. To do this, you have to add the following configuration for the dev environment: patchlevel_event_sourcing : watch_server : enabled : true Warning Use this configuration for dev purposes only! There is then a new command to start the watch server: bin/console event-sourcing:watch Note The command can be terminated with ctrl+c or control+c .","title":"Watch Server"}]}